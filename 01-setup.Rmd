# Setup {#intro}

## Navigate R markdown quickly 

* You can jump quickly to the right bit of code you want to edit in an R Markdown document in RStudio using the document outline. View the doc outline in one of three ways:

1. Hold down Ctrl+Shift+O. 
2. Click the top right icon in the code pane.
3. Left click on the bottom bar of the R markdown file. 

The gif below shows you these three methods. It was recorded with [ScreenToGif](https://www.screentogif.com/). I found it super easy to use and I felt worthy of donating to.

```{r, echo=FALSE, out.width = "100%"}
knitr::include_graphics("outline.gif") 
```

## Load R packages to your library

Here are all the R packages used in this book. 

```{r libraries, echo=TRUE,message=FALSE,warning=FALSE,results='hide'}
# data vis https://www.htmlwidgets.org/index.html
library(ggplot2) # static charts - amazing variety
library(plotly) # interactive charts
library(apexcharter) # much like the paid for highchater js library. Powerful
library(rayshader) # 3D charts
library(trelliscopejs) #  small multiples
library(dygraphs) # awesome interactive timeseries

# ggplot extensions https://www.ggplot2-exts.org/gallery/
library(scales) # improve your scales
library(gganimate) # animate your ggplot
library(png) # dunno
library(directlabels) # for directly labelling lines for example
library(gghighlight) # label points of interest on your charts
library(ggrepel) # move labels so they don't overlap
library(glue) # 

# colours
library(RColorBrewer) # ready to use colour pallets
library(prismatic) # palettes and ways to tweak an entier pallete

# tables
library(kableExtra) # attractive static tables
library(formattable) # colour tables. Like Excel's conditional formattinng
library(rpivotTable) # like Excel's pivot table
library(DT) # awesome interactive tables

# Quality Assurance
library(tidylog) # great for QA on the fly 

# wrangling / munging / manipulating
library(tidyverse) # loads of useful packages in one 

library(crosstalk) # link html widgets

# time series tools
library(anytime) # convert text into the right date type
library(xts) # convert to time series for dygraphs
library(tsbox) # easily convert to time series

# sample data
library(mosaicData) # sample data

```

## The data to visualise

* A lot of data visilisation is about showing values change over time. For this reason, instead of using a [built in data set](https://stat.ethz.ch/R-manual/R-devel/library/datasets/html/00Index.html) like iris or mtcars we are going to moslty use the [Texas housing sales ](http://vincentarelbundock.github.io/Rdatasets/doc/ggplot2/txhousing.html) time series data built into ggplot.

* If you're looking for more open data sets to test your data vis skills take a look at this [comprehensive list of R datasets](https://vincentarelbundock.github.io/Rdatasets/).

* The only manipulation we will do to the Texas housing sales data is create a real date using [lubridate](https://lubridate.tidyverse.org/). We also create a smaller data frame with fewer Texas cities so some plots aren't too crowded.

* We'll alo use [tidylog](https://github.com/elbersb/tidylog/blob/master/README.md) with dplyr. Tidylog is an easy way to include fast basic Quality Asssurance into your coding process. You just replace dplyr verbs with the same verb in tidylog. The tidylog version tells you what each dplyr verb has done to your data in terms of the number and percentage of changes. For example, how many rows are dropped or added by filters or joins, or what percentage of values changed after a mutate.

```{r create_df, message=TRUE}
# create a data frame with a real date for plotting
df <- ggplot2::txhousing %>% 
  tidylog::mutate(date = lubridate::make_date(year = year,
                                              month = month, 
                                              day =1)) 
```

* Let's also create a data frame with fewer cities to make some plots less crowded later. Here we select only cities where the maximum number in any month is 800 or more.

```{r}
# reduce the number of cities for simpler plots
df_red <- df %>% 
  dplyr::group_by(city) %>% 
  tidylog::mutate(sales_max = base::max(sales)) %>% 
  dplyr::ungroup() %>% 
  tidylog::filter(sales_max >= 500)
```

* Hold on. Look! Read the tidylog messages above. They tell us what percentage of values are "NA". The mutate must have gone wrong as it tells us there are 43% NA. Well spotted tidylog. We correct it below by removing NAs from the maximum sales value using na.rm = TRUE.

```{r}
# reduce the number of cities for simpler plots
df_red <- df %>% 
  dplyr::group_by(city) %>% 
  tidylog::mutate(sales_max = base::max(sales, 
                                        na.rm = TRUE)) %>% 
  dplyr::ungroup() %>% 
  tidylog::filter(sales_max >= 500)
```

* This version above is correct as the tidlog message above tells us there are 0% NA.

* Let's also look at the top few rows of the data frame using kableExtra table. A later chapter describes different table methods in more detail.

```{r}
kableExtra::kable(utils::head(df))
```

## Code style 

### Include the package and parameter names

* I started learning R using other people's code. I got confused where functions came from when they used many packages, base functions and their own functions. It made their code appear more complex than it really was.

* To make your code more transparent I reccomend using the package name before every function. Even base R functions. This helps people new to R and your future self who may have forgtten what you were doing. 

* Using the package name first also lets you use thethe tab key at the end of the double colon and browse all the functions in that package.

* Also, try highlighting a function and its package name then hit the F1 key. Also try highligting and hitting the F2 key. This can be a quick way to see all the possible parameters in a function. And see any parameter default values. 

* Also, name the parameters in each function instead of relying on the order the function expects them. This makes your code easier to read and understand when we know what the paramgeters are setting.

```{r package_name, eval=FALSE}
ggplot2::

ggrepel::geom_text_repel(mapping = )
```

```{r, echo=FALSE, out.width = "1100%"}
knitr::include_graphics("package_name.gif") 
```

### One line does one thing - hit the return key a lot

* Ideally one line of code does one thing. Hit the return key after every pipe (%>%), comma or plus (+) and RStudio tabs will space your code out in just the right way.

* For example, the code below works but doesn't follow the rules so far (Package & Paramater names and one action per line). The code is cramped, and slow to understand, edit or re-use.

```{r cramped_code, eval=FALSE}
ggplot(df) +
  geom_line(aes(date, sales, colour = city)) +
  ggplot2::theme_minimal() +
  gghighlight(max(sales) > 5000, label_params = list(size = 4)) +
  scale_y_continuous(labels = scales::comma) +
  scale_x_date(date_breaks = "1 year", labels = scales::date_format("%d %b %y"), limits = c(as.Date("2000-01-01"), as.Date("2015-07-01"))) +
  labs(title = "US Housing Sales over time", subtitle = "US cities with more than 5k sales in a month", caption = "Source: ggplot2 package demo data") +
  geom_vline(xintercept = years, linetype = 4) +
  theme(panel.grid.major.x = element_blank(), panel.grid.minor.x = element_blank(), strip.text.x = element_text(size = 10), axis.text.x = element_text(angle = 60, hjust = 1, size = 9), legend.text = element_text(size = 12), legend.position = "right", legend.direction = "vertical", plot.title = element_text(size = 22, face = "bold"), plot.subtitle = element_text(color = "grey", size = 18), plot.caption = element_text(hjust = 0, size = 12, color = "darkgrey"), legend.title = element_blank())
```

* In oontrast, the code below is the same code as above but it follows these 5 rules:

1. Include package names before each function. Even for [base functions](https://stat.ethz.ch/R-manual/R-devel/library/base/html/00Index.html).
2. Name every argument you set the value of in a function.
3. Each line does one thing (e.g. a function or the value of one argument in a function) by hitting the return key after each pipe ( %>% ), comma or plus symbol (+).
4. Put spaces around equals.
5. Use [styler](https://styler.r-lib.org/) to automatically apply some of these rules. 

The benefits of following these rules are that you can more easily:

1. Run your code top downwards in chunks adding more lines each time (like the popular ggplot flipbooks I describe at bullet 11 in my collection of [R guides and galleries](https://github.com/billster45/r-guides-and-galleries/blob/master/README.md#learn-to-visualise-data-with-r)
2. Comment out whole lines of code or parameters in a function to undersatnd what they are doing.
3. Find and edit paramaters in a function (e.g. a font size)
4. Help others QA or re-use your code more quickly.
5. Help others new to R understand what you are doing and learn R faster.
6. Avoid being a "gatekeeper" of your R knowledge and skills. Share, explain and democratise what you know. You can then move on to more complex analysis in R with an even higher value (as proposed by Richard Susskind in [The Future of Professions](https://www.amazon.co.uk/dp/0198713398/)).

```{r clean_code, eval=FALSE}
df %>%
  ggplot2::ggplot() +
  ggplot2::aes(
    x = date,
    y = sales,
    colour = city
  ) +
  ggplot2::geom_line() +
  ggplot2::theme_minimal() +
  gghighlight::gghighlight(max(sales) > 5000,
                           label_params = list(size = 4)
  ) +
  ggplot2::scale_y_continuous(labels = scales::comma) +
  ggplot2::scale_x_date(
    date_breaks = "1 year",
    labels = scales::date_format("%d %b %y"),
    limits = c(
      as.Date("2000-01-01"),
      as.Date("2015-07-01")
    )
  ) +
  ggplot2::labs(
    title = "US Housing Sales over time",
    subtitle = "US cities with more than 5k sales in a month",
    caption = "Source: ggplot2 package demo data"
  ) +
  ggplot2::geom_vline(
    xintercept = years,
    linetype = 4
  ) +
  ggplot2::theme(
    panel.grid.major.x = element_blank(),
    panel.grid.minor.x = element_blank(),
    strip.text.x = element_text(size = 10),
    axis.text.x = element_text(
      angle = 60,
      hjust = 1,
      size = 9
    ),
    legend.text = element_text(size = 12),
    legend.position = "right",
    legend.direction = "vertical",
    plot.title = element_text(
      size = 22,
      face = "bold"
    ),
    plot.subtitle = element_text(
      color = "grey",
      size = 18
    ),
    plot.caption = element_text(
      hjust = 0,
      size = 12,
      color = "darkgrey"
    ),
    legend.title = element_blank()
  )
```

* Note this layout differs from the [layered gramar of graphics](https://r4ds.had.co.nz/data-visualisation.html#the-layered-grammar-of-graphics) code template below...

```{r, eval = FALSE}
ggplot(data = <DATA>) + 
  <GEOM_FUNCTION>(
     mapping = aes(<MAPPINGS>),
     stat = <STAT>, 
     position = <POSITION>
  ) +
  <COORDINATE_FUNCTION> +
  <FACET_FUNCTION>
```

* My preference is to mentally view this as data being poured into ggplot through the pipe, then we tell it which columns to map, then the geom, followed by the same co-ordinate and facet function as Wickham reccomends. 

* This is inspired by the code layout of the many flipbook guides I describe at bullet 11 [here](https://github.com/billster45/r-guides-and-galleries/blob/master/README.md#learn-to-visualise-data-with-r).

```{r, eval=FALSE}
<DATA> %>% 
  ggplot2::ggplot() + 
  ggplot2::aes(<MAPPINGS>) +
  ggplot2::<GEOM_FUNCTION>(
     stat = <STAT>, 
     position = <POSITION>
  ) +
  <COORDINATE_FUNCTION> +
  <FACET_FUNCTION>
```


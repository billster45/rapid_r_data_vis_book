[
["index.html", "Rapid R Data Viz Book Chapter 1 Why read this? 1.1 The best data analysis is fast and intuitive 1.2 What about Python for data viz? 1.3 What about Point and Click tools? 1.4 Find an R master to inspire you", " Rapid R Data Viz Book Bill Cockerill 2019-10-28 Chapter 1 Why read this? 1.1 The best data analysis is fast and intuitive The best data analysis starts with fast and intuitive Exploratory Data Analysis (EDA). You are in a flow state absored by the patterns and stories your data reveals. This includes any kind of data work from data engineering to Kaggle Data Science competition winners. This book shows you as series of linked methods to use in a logical order to to explore and visualise data quickly before create quality final plots with clean and easily editable code. It is intended to be accessible by beginners in R to those with an intermediate level of skill. Even experienced R users could pick up a new trick or two by scanning this material quickly. Each method starts with simple code so it you can use it as part of a fast Exploratory Data Analysis (EDA) toolkit. Then a more complex version is provided you can adapt to turn it into publicatoin quality plots. This is my current approach to data visualiation in R. But my methods keep changing from reading R-Bloggers and #rstats daily. This diagram is from R for Data Science that summarises the overall Data Science workflow. We’re just going to look at the Visualise and Communicate parts underlined. And to emphasise the importance of clear well laid out code as also part of an internal communicationn to yourself and analysis colleagues. 1.2 What about Python for data viz? Python is great for data visualisation too through Pandas, Seaborn, Matplotlib, and Bokeh. My day to day work only allows R so this is where I’ve built most data vis skills so far. A good place to find similar examples with real data are Python Notebooks on Kaggle. Use the filters at the top to select popular data visulisation notebooks in Python. 1.3 What about Point and Click tools? Graphical User Interface (GUI) or Point and Click (PaC) tools like Excel, PowerBI and Tableau still have their place as long as we recognise their weaknesses. Hadley Wickham contrasts PaC tools vs code tools well in this interview. Point-and-click interfaces are great, because they lay out all of your options in front of you, and you don’t have to remember anything. You can navigate through the set of pre-supplied options. And that’s also it’s greatest weakness, because first of all, you are constrained into what the developer thought you should be able to do. And secondly, because your primary interaction is with a mouse, it’s very difficult to record what you did. And I think that’s a problem for science, because ideally you want to say how you actually got these results. And then simply do that reliably and have other people critique you on that. But it’s also really hard when you are learning, because when you have a problem, how do you communicate that problem to someone else? You basically have to say, “I clicked here, then I clicked here, then I clicked here, and I did this.” Or you make a screen cast, and it’s just clunky. So, the advantages of programming languages like R or Python, is that the primary mechanism for communicating with the computer is text. And that is scary because there’s nothing like this blinking cursory in front of you; it doesn’t tell you what to do next. But it means you are unconstrained, because you can do anything you can imagine. And you have all these advantages of text, where if you have a problem with your code, you can copy and paste it into an email, you can Google it, you can check it and put it on GitHub, or you can share it by Twitter. There’s just so many advantages to the fact that the primary way you relate with a programming language is through code, which is just text. And so, as long as you are doing data analysis fairly regularly, I think all the advantages outweigh a point and click interface like Stata. 1.4 Find an R master to inspire you 1.4.1 David Robinson How David Robinson explores, cleans then analystes data in R inspires me. Several methods I use here I saw Robinson use on his Tidy Tuesday live coding YouTube videos. I’d strongly reccomend watching any of his live coding videos here. This book is a narrow section of Data Science of visualise and communicate, but you will see Robinson tackle the whole data sciecne path from import to communicate shown in the diagram above. 1.4.2 Claus Wilke Another R master, Claus Wilke has created a new guide similar to this book. It starts with simple examples that become more complex. In his Practical ggplot2 guide see how he starts with the bare minimum code you need to create the plot then gradually builds it up into something that is publication quality. He wrote it to help you more easily make charts like those in the Fundamentals of Data Visualization. This book is similar to Wilke’s but with a greater focus on exploratory data analysis. I also offer a wider set of tools beyond ggplot (particulary for interactive plots, as well as a clean code style. "],
["intro.html", "Chapter 2 Setup 2.1 Navigating an R markdown 2.2 Load R packages to your library 2.3 The data to visualise 2.4 Code style", " Chapter 2 Setup 2.1 Navigating an R markdown A quick way to move around an R Markdown document in RStudio is through the document outline. You can see the outline by holding down Ctrl+Shift+O, clicking the top right icon in the code pane, or left clicking on the bottom bar of the R markdown file. The gif below shows you how it works. * Recorded with ScreenToGif: https://www.screentogif.com/ 2.2 Load R packages to your library Here are all the R packages that are used in this guide. # data vis https://www.htmlwidgets.org/index.html library(ggplot2) # static charts - amazing variety library(plotly) # interactive charts library(apexcharter) # much like the paid for highchater js library. Powerful library(rayshader) # 3D charts library(trelliscopejs) # small multiples library(dygraphs) # awesome interactive timeseries # ggplot extensions https://www.ggplot2-exts.org/gallery/ library(scales) # improve your scales library(gganimate) # animate your ggplot library(png) # dunno library(directlabels) # for directly labelling lines for example library(gghighlight) # label points of interest on your charts library(ggrepel) # move labels so they don&#39;t overlap # colours library(RColorBrewer) # ready to use colour pallets library(prismatic) # palettes and ways to tweak an entier pallete # tables library(kableExtra) # attractive static tables library(formattable) # colour tables. Like Excel&#39;s conditional formattinng library(rpivotTable) # like Excel&#39;s pivot table library(DT) # awesome interactive tables # Quality Assurance library(tidylog) # great for QA on the fly # wrangling / munging / manipulating library(tidyverse) # loads of useful packages in one library(glue) # not sure # time series tools library(anytime) # convert text into the right date type library(xts) # convert to time series for dygraphs library(tsbox) # easily convert to time series # sample data library(mosaicData) # sample data library(xfun) # https://github.com/vincentarelbundock/Rdatasets/blob/master/Rdatasets.R # https://vincentarelbundock.github.io/Rdatasets/ 2.3 The data to visualise A lot of data visilisation shows values changing over time. For this reason, instead of using a built in data set like iris or mtcars this guide uses a built-in data set within ggplot. It is the txhousing data set built into ggplot. It provides house sales in American cities over several years. If you’re looking for a smalll well behaved data set to test your skills take a look at this comprehensive list of R datasets. The only manipulation we will do on the txhousing data set is create a real date using lubrdate. We also create a smaller data frame with a smaller number of American cities so some of the plots aren’t too crowded. We’ll alo use tidylog with dplyr. It’s a simple way to do fast basic Quality Asssurance as you code. Simply replace dplyr verbs with the same verb in tidylog. This will tell you what each dplyr verb has done to your data. For example, how many rows are dropped or added by filters or joins, or what percentage of values changed after a mutate. # create a data frame with a real date for plotting df &lt;- ggplot2::txhousing %&gt;% tidylog::mutate(date = lubridate::make_date(year = year, month = month, day =1)) ## mutate: changed 8,602 values (100%) of &#39;date&#39; (0 new NA) Let’s also create a data frame with fewer cities. This will make plots less crowded later. Here we select only cities where the maximum number in any month is 800 or more. # reduce the number of cities for simpler plots df_red &lt;- df %&gt;% dplyr::group_by(city) %&gt;% tidylog::mutate(sales_max = base::max(sales)) %&gt;% dplyr::ungroup() %&gt;% tidylog::filter(sales_max &gt;= 500) ## mutate (grouped): new variable &#39;sales_max&#39; with 27 unique values and 43% NA ## filter: removed 6,171 rows (72%), 2,431 rows remaining But look! Read the messages above created by tiylog. It tells us what percentage of values are NA. The mutate must have gone wrong as it tells us there are 43% NA. Well spotted tidylog. We correct it below by removing NAs from the maximum sales value. # reduce the number of cities for simpler plots df_red &lt;- df %&gt;% dplyr::group_by(city) %&gt;% tidylog::mutate(sales_max = base::max(sales, na.rm = TRUE)) %&gt;% dplyr::ungroup() %&gt;% tidylog::filter(sales_max &gt;= 500) ## mutate (grouped): new variable &#39;sales_max&#39; with 45 unique values and 0% NA ## filter: removed 5,984 rows (70%), 2,618 rows remaining This has worked with 0% NA in the tidlog message above. Let’s now look at the top few rows of the data frame using kableExtra table. A later chapter explores tables. kableExtra::kable(utils::head(df)) city year month sales volume median listings inventory date Abilene 2000 1 72 5380000 71400 701 6.3 2000-01-01 Abilene 2000 2 98 6505000 58700 746 6.6 2000-02-01 Abilene 2000 3 130 9285000 58100 784 6.8 2000-03-01 Abilene 2000 4 98 9730000 68600 785 6.9 2000-04-01 Abilene 2000 5 141 10590000 67300 794 6.8 2000-05-01 Abilene 2000 6 156 13910000 66900 780 6.6 2000-06-01 2.4 Code style 2.4.1 Include the package name every time. Why? When I first started learning R I tried to teach myself using other people’s code. I got confused where functions came from, particularly when they mixed functions from many packages, base functions and their own functions. It made their code appear harder, more complex and cleverer than it really was. Instead I use the package name before every function. Even base R functions. This can help people new to R who read your code. And you can help you future self when you come back to code you did ages ago and have forgotten what you were doing. Another good reason to use the package name is being able to hit the tab key at the end of the double colon like this and see all the functions in that package. Also, try highlighting a function and its package name and hit the F1 key. (You’ll see David Robinson do this a lot even on his own packages.) Also try hitting the F2 key to quickly see all the possible parameters in a function and see what the defaults are that it will use if you don’t set them to a new value. ggplot2:: dplyr::arrange() ggrepel::geom_text_repel() 2.4.2 One line does one thing - hit the return key a lot Ideally one line does one thing. Hit the return key after every pipe, comma or plus symbol in ggplot and RStudio tabs your code in the right way. Also, name the parameters in each function instead of relying on theorder the function expects them. Your code is then easier to read by others and you later. For example, below this works but doesn’t follow any of those rules. The code is cramped and slow to understand, edit or re-use. ggplot(df) + geom_line(aes(date, sales, colour = city)) + ggplot2::theme_minimal() + gghighlight(max(sales) &gt; 5000, label_params = list(size = 4)) + scale_y_continuous(labels = scales::comma) + scale_x_date(date_breaks = &quot;1 year&quot;, labels = scales::date_format(&quot;%d %b %y&quot;), limits = c(as.Date(&quot;2000-01-01&quot;), as.Date(&quot;2015-07-01&quot;))) + labs(title = &quot;US Housing Sales over time&quot;, subtitle = &quot;US cities with more than 5k sales in a month&quot;, caption = &quot;Source: ggplot2 package demo data&quot;) + geom_vline(xintercept = years, linetype = 4) + theme(panel.grid.major.x = element_blank(), panel.grid.minor.x = element_blank(), strip.text.x = element_text(size = 10), axis.text.x = element_text(angle = 60, hjust = 1, size = 9), legend.text = element_text(size = 12), legend.position = &quot;right&quot;, legend.direction = &quot;vertical&quot;, plot.title = element_text(size = 22, face = &quot;bold&quot;), plot.subtitle = element_text(color = &quot;grey&quot;, size = 18), plot.caption = element_text(hjust = 0, size = 12, color = &quot;darkgrey&quot;), legend.title = element_blank()) In oontrast, the code below is the same code as above but it follows these 5 rules: Include package names before each function. Even for base functions. Each line does one thing (e.g. a function or the value of one argument in a function). Name every argument you set the value of in a function. Tabbed consistently by hitting the return key after each pipe ( %&gt;% ), comma or plus symbol (+). Put spaces around equals. Use styler to automatically apply some of these rules. The benefits of following these rules are that you can: Run your code top downwards in chunks adding more lines each time (like the popular ggplot flipbooks I describe at bullet 11 in my collection of R guides and galleries Comment out whole lines of code or parameters in a function to undersatnd what they are doing. Easily find and edit parameaters in a function (e.g. a font size) Help others QA or re-use your code more quickly. Help others new to R understand what you are doing and learn R faster. You are not being a “gatekeeper” of your growing R knowledge and skills. Share, explain and democratise what you know. You can then move on to more complex analysis in R with an even higher value (as proposed by Richard Susskind in The Future of Professions). df %&gt;% ggplot2::ggplot() + ggplot2::aes( x = date, y = sales, colour = city ) + ggplot2::geom_line() + ggplot2::theme_minimal() + gghighlight::gghighlight(max(sales) &gt; 5000, label_params = list(size = 4) ) + ggplot2::scale_y_continuous(labels = scales::comma) + ggplot2::scale_x_date( date_breaks = &quot;1 year&quot;, labels = scales::date_format(&quot;%d %b %y&quot;), limits = c( as.Date(&quot;2000-01-01&quot;), as.Date(&quot;2015-07-01&quot;) ) ) + ggplot2::labs( title = &quot;US Housing Sales over time&quot;, subtitle = &quot;US cities with more than 5k sales in a month&quot;, caption = &quot;Source: ggplot2 package demo data&quot; ) + ggplot2::geom_vline( xintercept = years, linetype = 4 ) + ggplot2::theme( panel.grid.major.x = element_blank(), panel.grid.minor.x = element_blank(), strip.text.x = element_text(size = 10), axis.text.x = element_text( angle = 60, hjust = 1, size = 9 ), legend.text = element_text(size = 12), legend.position = &quot;right&quot;, legend.direction = &quot;vertical&quot;, plot.title = element_text( size = 22, face = &quot;bold&quot; ), plot.subtitle = element_text( color = &quot;grey&quot;, size = 18 ), plot.caption = element_text( hjust = 0, size = 12, color = &quot;darkgrey&quot; ), legend.title = element_blank() ) Note this layout differs from the layered gramar of graphics code template below… ggplot(data = &lt;DATA&gt;) + &lt;GEOM_FUNCTION&gt;( mapping = aes(&lt;MAPPINGS&gt;), stat = &lt;STAT&gt;, position = &lt;POSITION&gt; ) + &lt;COORDINATE_FUNCTION&gt; + &lt;FACET_FUNCTION&gt; My preference is to mentally view this as data being poured into ggplot through the pipe, then we tell it which columns to map, then the geom, followed by the same co-ordinate and facet function as Wickham reccomends. This is inspired by the code lay out of the many flipbook guides I describe at bullet 11 here. &lt;DATA&gt; %&gt;% ggplot2::ggplot() + ggplot2::aes(&lt;MAPPINGS&gt;) + ggplot2::&lt;GEOM_FUNCTION&gt;( stat = &lt;STAT&gt;, position = &lt;POSITION&gt; ) + &lt;COORDINATE_FUNCTION&gt; + &lt;FACET_FUNCTION&gt; "],
["exploratory-data-analysis.html", "Chapter 3 Exploratory Data Analysis 3.1 Start with dplyr counts and summaries in console 3.2 Next plot data points 3.3 Now facet by categories 3.4 Facet interactively (trelliscopejs) 3.5 Or loop and plot every value 3.6 Polish your final plot", " Chapter 3 Exploratory Data Analysis 3.1 Start with dplyr counts and summaries in console David Robinson first explores new data with simple counts in the console. Here we don’t use the package name (so breaking the rule I just told you) so we can quickly explore the data by typing dplyr verbs quickly df %&gt;% count(city) %&gt;% View() df %&gt;% count(city, year, month) %&gt;% View()# df %&gt;% group_by(city) %&gt;% summarise(vol_max = max(volume, na.rm = T)) %&gt;% arrange(desc(vol_max)) %&gt;% View() 3.2 Next plot data points After using count(), group_by() and summarise() plot all data points with ggplot2::geom_point(). It almost NEVER fails to show you what’s going on and is unlikely to return errors. This is the minimum and most reliable ggplot code to start with. Let’s look at all the values of sales for each date. df %&gt;% ggplot2::ggplot() + ggplot2::aes( x = date, y = sales ) + ggplot2::geom_point() ## Warning: Removed 568 rows containing missing values (geom_point). Then look at sales over the values of any other dimensions. There is one other dimension city. df %&gt;% ggplot2::ggplot() + ggplot2::aes( x = sales, y = city ) + ggplot2::geom_point() ## Warning: Removed 568 rows containing missing values (geom_point). But those points look a bit crowded. Whenever the dots overlap replace geom_point() with geom_jitter(). And we make the dots lighter using a non-intuitive parameter called alpha. df %&gt;% ggplot2::ggplot() + ggplot2::aes( x = sales, y = city ) + ggplot2::geom_jitter(alpha = 0.1) ## Warning: Removed 568 rows containing missing values (geom_point). Of course we know sales of most things vary by season. Let’s put date on the x axis, make city the colour, and because the data is over time we can join those dots using ggplot2::geom_line() We’re also using the reduced data set so it’s not too crowded for now. df_red %&gt;% ggplot2::ggplot() + ggplot2::aes( x = date, y = sales, colour = city ) + ggplot2::geom_line() ## Warning: Removed 1 rows containing missing values (geom_path). Beautiful, while sales have very different volumes between cities we can see they tightly follow the same seasonal pattern. But the are on different scales so harder to compare the patterns. One option Wickham does is to log transform the sales value. df_red %&gt;% ggplot2::ggplot() + ggplot2::aes( x = date, y = base::log(sales), colour = city ) + ggplot2::geom_line() ## Warning: Removed 1 rows containing missing values (geom_path). 3.3 Now facet by categories Another logical step after showing categories by colour is to use “small multiples”. This is a fancy way of saying draw a chart for each category and look at them all at once in a grid. An important setting here is to specify scales = “free” so they are their own scale and we can study what’s going on in each city. This lets us more easily spot interesting differences in the seasonal pattern between cities. df_red %&gt;% ggplot2::ggplot() + ggplot2::aes( x = date, y = sales, colour = city ) + ggplot2::geom_line() + ggplot2::facet_wrap(~city, scales = &quot;free&quot; ) ## Warning: Removed 1 rows containing missing values (geom_path). 3.4 Facet interactively (trelliscopejs) An interactive way to facet (or create small multiples) that allows interactive data exploration is trelliscopejs. Here we look at all the US cities facetted by city in a trelliscope web page. Have a play on this below and see what it does. df %&gt;% ggplot2::ggplot() + ggplot2::aes( x = date, y = sales ) + ggplot2::geom_line() + trelliscopejs::facet_trelliscope(~city, scales = &quot;free&quot;, nrow = 3, ncol = 5, self_contained = TRUE, # as_plotly = TRUE, # not working plotly_cfg = list(displayModeBar = FALSE) ) 3.5 Or loop and plot every value Or to really study each chart, nest the data into a data frame of dataframes for each city. Then loop through each one and creating a plot in the data frame we plot. df_red_nest &lt;- df_red %&gt;% dplyr::group_by(city) %&gt;% tidyr::nest() df_red_nest %&gt;% View() df_red_nest[[2]][[1]] %&gt;% View() df_red_nest_plot &lt;- df_red_nest %&gt;% dplyr::mutate(plot = purrr::map2( .x = data, .y = city, ~ ggplot2::ggplot( data = .x, aes( x = date, y = sales ) ) + ggtitle(glue(&quot;Plot of {.y}&quot;)) + geom_line() )) df_red_nest_plot %&gt;% View() print(df_red_nest_plot$plot) ## [[1]] ## ## [[2]] ## ## [[3]] ## ## [[4]] ## ## [[5]] ## Warning: Removed 1 rows containing missing values (geom_path). ## ## [[6]] ## ## [[7]] ## ## [[8]] ## ## [[9]] ## ## [[10]] ## ## [[11]] ## ## [[12]] ## ## [[13]] ## ## [[14]] 3.6 Polish your final plot We now have a bare minimum Exploratory Data Analysis toolkit of how to explore the data from the console using View(), and then looking at the data points, followed by some line plots. We could soon be ready to decide on the plot we want that tells and interesting story. But adding in all the bells and whistles to make it ready for a customer or a publication can take ages. It shouldn’t be part of your exploratory data analysis. Also, we should use a code style recommended before that lays out your code cleanly. It’s far quicker then to comment out or tweak the values of each part of your plot until it looks just right. I won’t explain each line below other than to say you can run it in chunks to understand it like the popular ggplot flip-books. # a list of dates to add vertical lines to the plot years &lt;- base::seq.Date( from = as.Date(&quot;2000-01-01&quot;), to = as.Date(&quot;2015-01-01&quot;), by = &quot;years&quot; ) df %&gt;% ggplot2::ggplot() + ggplot2::aes( x = date, y = sales, colour = city ) + ggplot2::geom_line(size = 1) + ggplot2::theme_minimal() + gghighlight::gghighlight(base::max(sales) &gt; 5000, # highlight only cities with higher sales label_params = list(size = 4) ) + ggplot2::scale_y_continuous(labels = scales::comma) + ggplot2::scale_x_date( date_breaks = &quot;1 year&quot;, labels = scales::date_format(&quot;%b %Y&quot;), limits = c( as.Date(&quot;2000-01-01&quot;), as.Date(&quot;2015-07-01&quot;) ) ) + ggplot2::labs( title = &quot;US Housing Sales&quot;, subtitle = &quot;US cities with more than 5,000 sales in any month&quot;, caption = &quot;Source: ggplot2 built in txhousing data set&quot;, x = &quot;Month&quot;, y = &quot;Volume of Sales&quot; ) + ggplot2::geom_vline( xintercept = years, linetype = 4 ) + ggplot2::theme( panel.grid.major.x = element_blank(), panel.grid.minor.x = element_blank(), strip.text.x = element_text(size = 10), axis.text.x = element_text( angle = 60, hjust = 1, size = 9 ), legend.text = element_text(size = 12), legend.position = &quot;right&quot;, legend.direction = &quot;vertical&quot;, plot.title = element_text( size = 22, face = &quot;bold&quot; ), plot.subtitle = element_text( color = &quot;grey&quot;, size = 18 ), plot.caption = element_text( hjust = 0, size = 12, color = &quot;darkgrey&quot; ), legend.title = element_blank() ) ## label_key: city ## Warning: Removed 430 rows containing missing values (geom_path). So this isn’t necessarily a good plot. There’s things wrong with it I expect you’ll want to change. But with this clear ladder of code you can more quickly read, edit, comment chunks out, or run in chunks from the top down. "],
["why-start-with-geom-point.html", "Chapter 4 Why start with geom_point() ? 4.1 The problem with bars and columns 4.2 Go back to geom_point() 4.3 The final choice - geom_point() and stat_summary()", " Chapter 4 Why start with geom_point() ? 4.1 The problem with bars and columns We start with ggplot2::geom_point() because it works for for both raw and summrarised data straight away. And makes ggplot less intimidating when you start. It is famed for giving you errors see this tweet https://twitter.com/thomasp85/status/1170998101101953025?s=12 For example, here is raw granular data where each row describes a person getting married. marriage &lt;- mosaicData::Marriage %&gt;% tidylog::mutate(prev_marriage = as.character(prevconc)) %&gt;% tidylog::mutate(prev_marriage = case_when( is.na(prev_marriage) ~ &quot;First Time&quot;, TRUE ~ prev_marriage )) %&gt;% tidylog::mutate(ceremonydate1 = lubridate::parse_date_time(ceremonydate, &quot;mdy&quot;)) ## mutate: new variable &#39;prev_marriage&#39; with 3 unique values and 49% NA ## mutate: changed 48 values (49%) of &#39;prev_marriage&#39; (48 fewer NA) ## mutate: new variable &#39;ceremonydate1&#39; with 49 unique values and 0% NA kableExtra::kable(utils::head(marriage %&gt;% dplyr::select(ceremonydate1, person, prev_marriage, age, race, sign))) ceremonydate1 person prev_marriage age race sign 1996-11-09 Groom First Time 32.60274 White Aries 1996-11-12 Groom Divorce 32.29041 White Leo 1996-11-27 Groom Divorce 34.79178 Hispanic Pisces 1996-12-07 Groom Divorce 40.57808 Black Gemini 1996-12-14 Groom First Time 30.02192 White Saggitarius 1996-12-26 Groom First Time 26.86301 White Pisces Before we had one value per city and date so geom_line worked fine as long as the date and the city were in the “aesthetics” of the plot (e.g. x,y, colour, category, or facet being the most common). A common error with raw data I keep making is to try and put it into a bar or line chart straight away then get confused by the error or the chart. marriage %&gt;% ggplot2::ggplot() + ggplot2::aes( x = prev_marriage, y = age ) + ggplot2::geom_bar() ## Error: stat_count() must not be used with a y aesthetic. ggplot2::geom_col() would be a better choice but we still have to think to much about what it’s showing. Yes a bar plot might be the right choice for our final plot but it’s sometimes troublesome when we want to explore quickly. marriage %&gt;% ggplot2::ggplot() + ggplot2::aes( x = prev_marriage, y = age ) + ggplot2::geom_col() One reason for this is with bars we can be starting a statistical transformation without realising it. This is well exlainned in the Statistical Transformatoins chapter of R for Data Science 4.2 Go back to geom_point() Here we use ggplot2::geom_point() and facet by person marriage %&gt;% ggplot2::ggplot() + ggplot2::aes( x = prev_marriage, y = age ) + ggplot2::facet_wrap(~person) + ggplot2::geom_point(alpha = 0.3) Immediately this is interesting as we see the ages of brides and grooms and what happened in their previous marriage! Death, Divorce or Unknown! Based on the distribution of those points that are so pleasingly intuitive we can go on to experiment with different classic ways to represent the distributions we see. So first histograms marriage %&gt;% ggplot2::ggplot() + ggplot2::aes(x = age) + ggplot2::facet_wrap(~ person + prev_marriage) + ggplot2::geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Or the density distribution with ggplot2::geom_density() p &lt;- marriage %&gt;% ggplot2::ggplot() + ggplot2::aes( x = age, fill = prev_marriage ) + ggplot2::geom_density(adjust = 1, alpha = 0.5, colour = NA) + ggplot2::facet_wrap(vars(person), ncol = 1) + ggplot2::theme_minimal() directlabels::direct.label(p, list(&quot;top.points&quot;, cex = .75, hjust = 0, vjust = -0.2)) 4.3 The final choice - geom_point() and stat_summary() However, with so few data points I personally prefer the geom_point chart. marriage %&gt;% ggplot2::ggplot() + ggplot2::aes( x = prev_marriage, y = age ) + ggplot2::facet_wrap(~person) + ggplot2::geom_boxplot(alpha = 0.8) + ggplot2::geom_point(alpha = 0.3) + ggplot2::theme_light() And this evolution of a ggplot also starts with a boxplot but ends up with geom_point() and stat_summary() shown below is fantastic with full code in a gradualy story like this book. Inspired by that plot if we steal some of the methods.. p &lt;- marriage %&gt;% dplyr::group_by(person,prev_marriage) %&gt;% dplyr::mutate(pers_prev_avg = median(age)) %&gt;% dplyr::ungroup() %&gt;% dplyr::group_by(person) %&gt;% dplyr::mutate(pers_avg = median(age)) %&gt;% dplyr::ungroup() %&gt;% ggplot2::ggplot() + ggplot2::aes( x = prev_marriage, y = age, colour = prev_marriage ) + ggplot2::facet_wrap(~person, ncol = 1) + ggplot2::stat_summary(fun.y = median, geom = &quot;point&quot;, size = 5) + ggplot2::stat_summary(aes(label= paste( round(..y..,1), &quot; years&quot;)), fun.y=median, colour = &quot;black&quot;, geom=&quot;text&quot;, size=3, vjust = -1.5) + ggplot2::geom_hline(aes(yintercept = pers_avg), color = &quot;gray70&quot;, size = 0.6) + ggplot2::geom_text(aes(x = 0.7, y = pers_avg, label = paste(person,&quot; averge age&quot;, round(pers_avg,0)), #colour = &quot;white&quot;, hjust = 1.05), colour = &quot;black&quot;, size = 3) + ggplot2::geom_segment(aes(x = prev_marriage, xend = prev_marriage, y = pers_avg, yend = pers_prev_avg), size = 0.8) + ggplot2::geom_jitter(size = 2, alpha = 0.4, width = 0.2) + ggplot2::scale_color_brewer(type = &quot;qual&quot;, palette = &quot;Dark2&quot;) + ggplot2::theme_minimal()+ ggplot2::theme( plot.title = element_text(size = 14, hjust = 0), legend.position = &quot;none&quot;, axis.title.x = element_blank(), axis.title.y = element_blank(), panel.grid = element_blank(), strip.text.x = element_text(size = 12, hjust = 0.1), panel.border = element_rect(colour = &quot;black&quot;, fill=NA, size = 0.1) ) + ggplot2::scale_y_continuous(breaks=base::seq(0,100,10)) + ggplot2::coord_flip() + ggplot2::labs( title = &quot;Average median* age by previous marriage status&quot;, caption = &quot;*The median is the middle age among all ages when sorted in order so that 50% of ages fall below that value and 50% above it&quot; ) ggplot2::ggsave(file=&quot;marriage.svg&quot;, device = &quot;svg&quot;, plot=p) ## Saving 7 x 5 in image ## Warning: package &#39;gdtools&#39; was built under R version 3.6.1 "],
["interactive-plots.html", "Chapter 5 Interactive plots 5.1 Plotly cheat: convert ggplot with plotly::ggplotly() 5.2 Edit ggplot conversion with plotly::plotly_build() 5.3 Plotly most basic 5.4 plotly (a few more settings) 5.5 plotly (bells &amp; whistles) 5.6 apexchater simple 5.7 apexchater with bells &amp; whistles 5.8 dygraphs for time series data 5.9 dygraphs bells &amp; whistles", " Chapter 5 Interactive plots 5.1 Plotly cheat: convert ggplot with plotly::ggplotly() Interactive plots help you and your audience find stories in data faster and more enjoyably. Carson Sievert (who maintains the Plotly R package) showed in a talk how interactive plots can “augment” your data exploration but only if we an “iterate quickly”. And this is possible with how easy and tolerant plotly is to use. However, while plotly is fast to explore, adding the final polish can be harder than ggplot. Sievert also uses the same A quick way to use Plotly that builds on your ggplot skills is to put it through a plotly function called plotly::ggplotly() like this… p &lt;- df_red %&gt;% ggplot2::ggplot() + ggplot2::aes(x = date, y = sales, colour = city) + ggplot2::geom_line() plotly::ggplotly(p) 5.2 Edit ggplot conversion with plotly::plotly_build() Often, even with editing how the original ggplot looks, the plotly::ggplotly() function doesn’t quite convert to what you wnat. If this happens use plotly::plotly_build() instead to build a plotly plot where you can edit all the settings. plotly::plotly_build() creates a nested list of all the settings you can explore in RStudio using the viewer. Here is how we create a plotly_build(). p &lt;- df_red %&gt;% ggplot2::ggplot() + ggplot2::aes(x = date, y = sales, colour = city) + ggplot2::geom_line() p_build &lt;- plotly::plotly_build(p) And now we later any of the setgins in p_build like this. Here we have edited the font size on the x axis to be a very small size 8. p_build[[&quot;x&quot;]][[&quot;layout&quot;]][[&quot;xaxis&quot;]][[&quot;tickfont&quot;]][[&quot;size&quot;]] = 8 p_build But of course that code above is very fiddly to work out. The gif below shows you how to browse the nested structure with the viewer and then automatically geneate the code you need to edit each value. 5.3 Plotly most basic Plotly is very forgiving. Here we don’t tell it what kind of plot we want (such as points or lines) but it still creates a plot. And thanfully it’s our friend data points.. df_red %&gt;% plotly::plot_ly(x = ~date, y = ~sales, color = ~city) 5.4 plotly (a few more settings) with a few more settings we can make it a line plot https://plot.ly/r/line-and-scatter/ df_red %&gt;% plotly::plot_ly(x = ~date, y = ~sales, color = ~city, type = &#39;scatter&#39;, mode = &#39;lines&#39;) 5.5 plotly (bells &amp; whistles) And as before add some bells and whistles to get close to our final plot. ax &lt;- list( title = &quot;&quot;, zeroline = FALSE, showline = FALSE, showticklabels = FALSE, showgrid = FALSE ) df_red %&gt;% plotly::plot_ly(x = ~date, y = ~sales, text = rownames(df_red)) %&gt;% add_lines(color = ~city, colorscale = &quot;set3&quot;) %&gt;% rangeslider() %&gt;% plotly::layout(xaxis = ax, yaxis = ax) Here are some good further plotly resources https://plotly-r.com/index.html https://moderndata.plot.ly/tufte-style-visualizations-in-r-using-plotly/ 5.6 apexchater simple The highcharter package creates interactive charts to the quality you often see on newspaper websites. It can produce great data visualisaiotns like these poll tracking charts. However, it’s not free to use. ApexCharter is almost as good, is inspried by highcharter, and is free to use. Look how easily we can create a chart with it just using this code. df_red %&gt;% apexcharter::apex(type = &quot;line&quot;, mapping = aes(x = date, y = sales, group = city )) 5.7 apexchater with bells &amp; whistles To add the bells and whistles the apexcharter reference is very well laid out with good examples. Here I’ve put in some useful ones in a clear code format. df_red %&gt;% apexcharter::apex(aes(x = date, y = sales, group = city), type = &quot;line&quot;) %&gt;% apexcharter::ax_legend(position = &quot;right&quot;) %&gt;% apexcharter::ax_stroke(width = 2) %&gt;% #apexcharter::ax_colors(mypalette) %&gt;% apexcharter::ax_yaxis( title = list(text = &quot;Sales&quot;) ) %&gt;% apexcharter::ax_xaxis(labels = list(format = &quot;yyyy&quot;)) %&gt;% apexcharter::ax_labs( title = &quot;apexcharter chart for sales by City&quot;, subtitle = &quot;this is a subtitle&quot; ) %&gt;% apexcharter::ax_title( style = list(fontSize = &quot;22px&quot;) ) %&gt;% apexcharter::ax_subtitle( style = list(fontSize = &quot;16px&quot;, color = &quot;#BDBDBD&quot;) ) %&gt;% apexcharter::ax_chart(zoom = list( enabled = TRUE, type = &quot;xy&quot; )) 5.8 dygraphs for time series data Similar in style to apexchater is the excellent dygraphs for when your data is a time series… One hurdle is your data frame needs to be a time series. A really easy way to convert is the tsbox pacakge http://rstudio.github.io/dygraphs/ https://www.tsbox.help/articles/tsbox.html df_red_ts &lt;- df_red %&gt;% dplyr::select(date,city,sales) %&gt;% tsbox::ts_xts() ## [time]: &#39;date&#39; [value]: &#39;sales&#39; df_red_ts %&gt;% dygraphs::dygraph() 5.9 dygraphs bells &amp; whistles Again, here is a bells &amp; whilstles version you can play around with to get it how you like. The help pages for dygraphs are very well laid out. Pretty much you only need this one guide to find out how to change all the settings possible: https://rstudio.github.io/dygraphs/ dateWindow &lt;- c(&quot;2014-01-01&quot;, &quot;2015-07-01&quot;) presAnnotation &lt;- function(dygraph, x, text) { dygraph %&gt;% dyAnnotation(x, text, width = 60) } presBankHolidays &lt;- function(dygraph) { dygraph %&gt;% dyEvent(&quot;2014-07-03&quot;, &quot;Independence Day&quot;, labelLoc = &quot;bottom&quot;) %&gt;% dyEvent(&quot;2014-11-26&quot;, &quot;Thanksgiving&quot;, labelLoc = &quot;bottom&quot;) } df_red_ts %&gt;% dygraphs::dygraph(main = &quot;Housing Sales USA&quot;) %&gt;% # https://github.com/rstudio/dygraphs/issues/80 dyAxis( &quot;y&quot;, label = &quot;Sales&quot;, # http://stackoverflow.com/questions/2901102/how-to-print-a-number-with-commas-as-thousands-separators-in-javascript valueFormatter = &#39;function(d){return d.toString().replace(/\\\\B(?=(\\\\d{3})+(?!\\\\d))/g, &quot;,&quot;);}&#39;, axisLabelFormatter = &#39;function(d){return d.toString().replace(/\\\\B(?=(\\\\d{3})+(?!\\\\d))/g, &quot;,&quot;);}&#39;, axisLabelFontSize = 10, axisLabelWidth = 70 ) %&gt;% dyRangeSelector( height = 60, dateWindow = dateWindow ) %&gt;% dyShading( from = &quot;2014-1-1&quot;, to = &quot;2014-12-31&quot; ) %&gt;% presBankHolidays() %&gt;% dyLegend(width = 600) %&gt;% presAnnotation(&quot;2014-07-01&quot;, text = &quot;2014&quot;) %&gt;% presAnnotation(&quot;2015-06-01&quot;, text = &quot;2015&quot;) %&gt;% dyOptions(colors = RColorBrewer::brewer.pal(8, &quot;Set2&quot;)) %&gt;% dyOptions(drawPoints = TRUE, pointSize = 2) %&gt;% dyLegend( show = &quot;always&quot;, hideOnMouseOut = FALSE ) "],
["animation.html", "Chapter 6 Animation", " Chapter 6 Animation Animation is easy to add. I’ve had a play here inspired by a good Tweet of examples you can easily adapt. However, I’ve found animation is most effective when you see changes over time. Here is the annual pattern of house sales changing each year. Getting the labels to display at the end of each line as it animates is fiddly. # Method from: https://github.com/thomasp85/gganimate/wiki/Temperature-time-series # https://stackoverflow.com/questions/54945861/problems-with-geom-text-and-pausing-the-animation # for each city and year find the sales value in the latest month availalbe # usually this is 12 but sometimes it&#39;s an earlier month label_anim &lt;- df %&gt;% dplyr::group_by(city,year) %&gt;% dplyr::summarise(max_month = max(month)) %&gt;% dplyr::ungroup() %&gt;% dplyr::inner_join(df_red, by = c(&quot;city&quot;=&quot;city&quot;, &quot;year&quot;=&quot;year&quot;, &quot;max_month&quot; = &quot;month&quot;)) %&gt;% dplyr::mutate(label_it = sales) %&gt;% dplyr::select(city,year,max_month,label_it) colors &lt;- c(&quot;Houston&quot; = &quot;#D9717D&quot;, &quot;Dallas&quot; = &quot;#4DB6D0&quot;, &quot;Austin&quot; = &quot;#BECA55&quot;) p &lt;- df %&gt;% dplyr::filter(city %in% c(&quot;Houston&quot;, &quot;Dallas&quot;, &quot;Austin&quot;)) %&gt;% dplyr::left_join(label_anim, by = c(&quot;city&quot; = &quot;city&quot;,&quot;year&quot; = &quot;year&quot;)) %&gt;% ggplot2::ggplot() + ggplot2::aes(x = month, y = sales, colour = city) + ggplot2::geom_line(size = 2) + ggplot2::theme_minimal() + ggplot2::coord_cartesian(clip = &#39;off&#39;) + # allow labels outside of plot ggplot2::theme(legend.position = &quot;none&quot;) + gganimate::transition_states(states = year, transition_length = 3, state_length = 1) + ggplot2::labs(title = &quot;US Housing Sales in : {closest_state}&quot;, caption = &quot;Source: ggplot2 package demo data&quot; ) + ggplot2::theme(plot.title = element_text(hjust = 1, vjust = -10, size = 30), panel.grid.major.x = element_blank(), panel.grid.minor.x = element_blank(), strip.text.x = element_text(size = 15), axis.text.x = element_text(size = 15), axis.text.y = element_text(size = 15), plot.caption = element_text( hjust = 0, size = 12, color = &quot;darkgrey&quot; ) ) + ggplot2::scale_color_manual(values = colors) + ggplot2::scale_x_continuous(name = &quot;Month&quot;, limits = c(1,13), breaks = c(1,2,3,4,5,6,7,8,9,10,11,12), label = c(&quot;Jan&quot;,&quot;Feb&quot;,&quot;Mar&quot;,&quot;Apr&quot;,&quot;May&quot;,&quot;Jun&quot;,&quot;Jul&quot;,&quot;Aug&quot;,&quot;Sep&quot;,&quot;Oct&quot;,&quot;Nov&quot;,&quot;Dec&quot;)) + ggplot2::geom_text(aes(x = max_month, y = label_it, label = city), hjust = 0, size = 8) gganimate::animate(p, width = 900, height = 600, end_pause = 10, fps = 20, rewind = FALSE, duration = 15) gganimate::anim_save(filename = &quot;housing.gif&quot;) "],
["tables.html", "Chapter 7 Tables 7.1 DataTables (DT) basic 7.2 DataTables bells &amp; whisltes 7.3 Colour DataTable with formattable 7.4 rpivottable simple 7.5 rpivottable (bells &amp; whistles)", " Chapter 7 Tables 7.1 DataTables (DT) basic For plotting we usually have tidy data where the data frame is “long” and each row represents one observation. Howver, for easy to read tables we usually need to make our long tidy data wide so that there are many observations in each row. Below we use tidyr::pivot_wider(), then put that wide data frame into an interactive table using DT # first reshape with new tidyr df_wide &lt;- df %&gt;% dplyr::filter(year == 2014) %&gt;% dplyr::arrange(city,date) %&gt;% dplyr::mutate(date1 = base::format(date, &quot;%b %y&quot;)) %&gt;% tidyr::pivot_wider(id_cols = city, names_from = date1, values_from = sales) df_wide %&gt;% DT::datatable(df_wide) 7.2 DataTables bells &amp; whisltes The DataTables reference is excellent for showing all the elements you can change with clear examples. Often you have decided on lots of differet [options][https://rstudio.github.io/DT/options.html] then want apply that to many later DataTables in your work. A way to save a lot of code is to set your main options globally like this… options(DT.options = list( pageLength = 10, lengthMenu = c(5, 10, 20, 50, 100, 200, 500), dom = &quot;Blfrtip&quot;, buttons = list(list(extend = &quot;csv&quot;, filename = &quot;download&quot;)), keys = TRUE, autoWidth = TRUE )) Then the settings above will be applied to every call df_wide %&gt;% DT::datatable( caption = &quot;Housing sales&quot;, filter = &quot;top&quot;, extensions = c(&quot;FixedColumns&quot;, &quot;Buttons&quot;), options = list(columnDefs = list(list(width = &quot;150px&quot;, targets = c(1)))) ) 7.3 Colour DataTable with formattable Colouring DataTables based on the value is a common client request. Here is how to colour # find 8 cut points going from the smallest to the largest value of sales in 2014 cuts &lt;- base::seq(from = min(df$sales[df$year==2014], na.rm = TRUE), to = max(df$sales[df$year==2014], na.rm=TRUE), length.out = 8) # define 9 colours for those cut points (1 more than the cut points needed) colours &lt;- RColorBrewer::brewer.pal(n = 9,name = &quot;Blues&quot;) # columns to format cols &lt;- base::seq(from = 2, to = ncol(df_wide), by = 1) df_wide %&gt;% dplyr::mutate_if(.predicate = base::is.character, .funs = base::as.factor) %&gt;% # converts an character columns to a factor so that the drop down menu works in the DataTable DT::datatable( caption = &quot;Housing sales&quot;, filter = &quot;top&quot;, extensions = c(&quot;FixedColumns&quot;, &quot;Buttons&quot;), options = list(columnDefs = list(list(width = &quot;150px&quot;, targets = c(1)))) ) %&gt;% DT::formatStyle(columns = cols, background = DT::styleInterval(cuts = cuts, values = colours)) %&gt;% DT::formatCurrency(columns = cols, currency = &quot;&quot;, digits = 0, interval = 3, mark = &#39;,&#39;) 7.4 rpivottable simple I love Excel pivot tables and charts for exploring data. rpivotables can be a good exploratory tool too. We can simply put the data frame into the function. Then play around with the html output below as you would an Excel pivot table to explore the data. rpivotTable::rpivotTable(data = df_red) 7.5 rpivottable (bells &amp; whistles) Once we’ve played around with it manually we can specify the most useful lay out that tells our story. The html table below can still be manipulated as we wish. rpivotTable::rpivotTable(data = df_red, rows = c(&quot;year&quot;,&quot;city&quot;), cols = &quot;date&quot;, inclusions = list(year = list(&quot;2014&quot;)), aggregatorName = &quot;Sum&quot;, vals = &quot;sales&quot;, rendererName = &quot;Line Chart&quot;) "],
["colours.html", "Chapter 8 Colours 8.1 Prismatic 8.2 Hand picked colours", " Chapter 8 Colours ##Color Brewer We’ve already used colours in some of the code. Particularly the pallettes in the RColorBrewer package. It has some ready made palletes that we can view like this. # easy colours RColorBrewer::display.brewer.all() And the display can be limited to colour blind friendly palettes. display.brewer.all(colorblindFriendly = TRUE) we can set up a pallete of colours like this and view them in a simple bar plot mypalette &lt;- RColorBrewer::brewer.pal(9,&quot;Set2&quot;) ## Warning in RColorBrewer::brewer.pal(9, &quot;Set2&quot;): n too large, allowed maximum for palette Set2 is 8 ## Returning the palette you asked for with that many colors graphics::barplot(1:9,col = mypalette) 8.1 Prismatic Prismatic lets us play around with palettes by shifting the entire set at once. For example, starting with terrain.. terrain &lt;- prismatic::colour(terrain.colors(10)) plot(terrain) Turn the pallete grey terrain_gray &lt;- prismatic::clr_grayscale(terrain) plot(terrain_gray) Darken the pallete terrain_darken &lt;- prismatic::clr_darken(terrain) plot(terrain_darken) Make the pallete negative terrain_negate &lt;- prismatic::clr_negate(terrain) plot(terrain_negate) 8.2 Hand picked colours You can also hand pick your own colours from this colour picking website reccomedned on an excellent blog post on using colours in ggplot by by Michael Toth. The colour picking website was used to create then copy and paste the colours below. newpalette &lt;- c(&quot;#804759&quot;,&quot;#713E4E&quot;,&quot;#633543&quot;,&quot;#562D39&quot;,&quot;#48252F&quot;,&quot;#3B1D25&quot;) barplot(1:6,col = newpalette) "],
["final-document.html", "Chapter 9 Final document 9.1 Picking a final output doc 9.2 crosstalk 9.3 flexdashboard 9.4 R markdown with floating contents and tabbed pates", " Chapter 9 Final document 9.1 Picking a final output doc After all our hard work it can have excellent impact if use a well structured and easy to navigate html document. I have found using cross talk in an R Markdown with a table of contens and tabbed pages, or with flexdashboard are two great options. And writing this book has made be realise how simple bookdown is to use. The different methods are demonstrated below. 9.2 crosstalk df_crosstalk &lt;- crosstalk::SharedData$new(df, ~year) crosstalk::filter_select( id = &quot;year&quot;, label = &quot;Select a year&quot;, allLevels = TRUE, multiple = FALSE, sharedData = df_crosstalk, group = ~ factor(year) ) Select a year df_crosstalk %&gt;% plotly::plot_ly(x = ~date, y = ~sales, color = ~city, type = &#39;scatter&#39;, mode = &#39;lines&#39;) ## Warning in RColorBrewer::brewer.pal(N, &quot;Set2&quot;): n too large, allowed maximum for palette Set2 is 8 ## Returning the palette you asked for with that many colors ## Warning in RColorBrewer::brewer.pal(N, &quot;Set2&quot;): n too large, allowed maximum for palette Set2 is 8 ## Returning the palette you asked for with that many colors 9.3 flexdashboard Flexdashboard example by Matt Dray coves all the bases. https://arm.rbind.io/slides/flexdashboard.html#1 9.4 R markdown with floating contents and tabbed pates "]
]

[
["index.html", "Rapid R Data Viz Book Chapter 1 tl;dr", " Rapid R Data Viz Book Bill Cockerill 2020-02-15 Chapter 1 tl;dr Exploratory data analysis (EDA) is the foundation for all data tasks. Do most of your EDA with just dplyr::count() and ggplot2::geom_point(). Use more ggplot functions to polish your final plot. But don’t worry about remembering all the ggplot functions and arguments, use Google. Follow three simple rules to layout your code clearly so that each line does one thing, name where each function comes from, and name all function arguments you set. Use interactive tools for EDA and presenting your final plot too (plotly, dygraphs, apexcharter, and rpivotTables). Use animation sparingly, and usually only to show change over time. Present your final plots in one of: flexdashhboards, R Markdown with a floating table of contents and tabbed sections, or a bookdown book. "],
["why-read-this.html", "Chapter 2 Why read this? 2.1 Good data analysis starts with fast &amp; intuitive EDA 2.2 Is this Data Science? 2.3 What about Python for data viz? 2.4 What about Point and Click data vis tools? 2.5 Find an R master to inspire you", " Chapter 2 Why read this? 2.1 Good data analysis starts with fast &amp; intuitive EDA Good Exploratory Data Analysis (EDA) is the foundation of most data work from data engineering to Kaggle Data Science competition winners. Ideally, you can explore your data quickly and intuitively in a flow state. You become absorbed by the patterns and stories the exploration of your data reveals, not slowed by code errors and Google searches. This book aims to help you explore data faster and with fewer errors. While at the same time to not compromise on code clarity and quality. Your quickly created code can still be easy to read and re-use with only three simple Code style rules to follow. The following chapters describe a set of linked methods in a logical order. We start first with methods to explore and visualise data quickly before you select a plot to start the intense process of polishing your final plot. We will also cover how interactive plots can be part of that rapid exploration too. Finally, we will see how to create visually appealing tables, colour palettes, and three impactful HTML formats to present your work. All the examples are aimed at beginners in R to those with an intermediate level of experience. However, even very experienced R users might pick up a new trick. And anyone can suggest an improvement or addition to this book as an issue. Each section starts with a bare-bones code example that can become part of your fast Exploratory Data Analysis toolbox. After each simple code example, a more sophsiticated version is provided in well-structured code. The more detailed examples you can use as a template to re-use for your final polished plots. The book is my current approach to data visualisation in R. But my methods keep changing and improving from reading R-Bloggers and #rstats and Slack channels every day. 2.2 Is this Data Science? The diagram below is the Data Science workflow from R for Data Science. I’ve underlined the parts of the Data Science process which this book aims to help you with, Visualise and Communicate. I’ve also added “Code Communication” to emphasise how well laid out code is another essential part of communicating. Clear code should be easy to read and understand, re-use, and quality assure. You are also helping your future yourself in case you forget what you were trying to do. Modelling is still an important part of both your data exploration and understanding and the overall Data Science process. The goal of modelling is described well in the R 4 Data Science modelling chapter: “The goal of a model is to provide a simple low-dimensional summary of a dataset. Ideally, the model will capture true “signals” (i.e. patterns generated by the phenomenon of interest), and ignore “noise” (i.e. random variation that you’re not interested in).\" Also, here is good example of modelling that conveniently uses the same Texas housing sales data we will use later in this book. 2.3 What about Python for data viz? Python is also a powerful data visualisation programming language. You will use packages such as Pandas, Seaborn, Matplotlib, and Bokeh. A good place to find similar data visualisation code examples to this book in Python are Kaggle notebooks. This link sets the filters at the top of the notebooks to show the most popular Python notebooks for visualisation. And here is the same link but filtering to the R language. 2.4 What about Point and Click data vis tools? Point and Click (PaC) tools like Excel, PowerBI and Tableau still have their place in EDA. As long as we understand their strengths and weaknesses compared to using code. Hadley Wickham compares PaC tools with code in this interview. Point-and-click interfaces are great, because they lay out all of your options in front of you, and you don’t have to remember anything. You can navigate through the set of pre-supplied options. And that’s also it’s greatest weakness, because first of all, you are constrained into what the developer thought you should be able to do. And secondly, because your primary interaction is with a mouse, it’s very difficult to record what you did. And I think that’s a problem for science, because ideally you want to say how you actually got these results. And then simply do that reliably and have other people critique you on that. But it’s also really hard when you are learning, because when you have a problem, how do you communicate that problem to someone else? You basically have to say, “I clicked here, then I clicked here, then I clicked here, and I did this.” Or you make a screen cast, and it’s just clunky. So, the advantages of programming languages like R or Python, is that the primary mechanism for communicating with the computer is text. And that is scary because there’s nothing like this blinking cursory in front of you; it doesn’t tell you what to do next. But it means you are unconstrained, because you can do anything you can imagine. And you have all these advantages of text, where if you have a problem with your code, you can copy and paste it into an email, you can Google it, you can check it and put it on GitHub, or you can share it by Twitter. There’s just so many advantages to the fact that the primary way you relate with a programming language is through code, which is just text. And so, as long as you are doing data analysis fairly regularly, I think all the advantages outweigh a point and click interface like Stata. 2.5 Find an R master to inspire you This book is just one set of ideas in a particular style. It’s not a rigid formula you must follow. Seek ideas and inspiration from a variety of people and books. Find your path in Data Science, data exploration, visualisation, and communication. Two people who have inspired me are David Robinson and Claus Wilke I describe below. I’ve also collected a series of R guides and galleries in a logical order I have found useful and inspiring. 2.5.1 David Robinson I recommend watching any of David Robinson’s live coding Tidy Tuesday videos to improve your Data Science skills. Robinson explores, cleans and then analyses data in R rapidly and intuitively. Precisely what I’m trying to help you do with this book. Several methods I use in this book I saw Robinson do first on his videos. While this book covers the exploration, visualisation and communication parts of Data Science, Robinson takes you through the complete R for Data Science workflow from import to communicate. And all in one hour (or less if you increase the playback speed to 1.5x). Amazingly Robinson has never seen the data he analyses before he starts. You get to witness how rapid it is possible to be doing Data Science in R. 2.5.2 Claus Wilke Another R master in data vis and communication is Claus Wilke. He recently created a guide similar to this book. It starts with simple examples that become more complex. In his Practical ggplot2 guide, he begins with the bare minimum code you need to create the plot. He then gradually builds the code up layer by layer until it is publication quality. Wilke wrote Practical ggplot2 to help people re-create some of the charts in his excellent Fundamentals of Data Visualization. This book offers a similar gradual method to Wilke’s but with a greater focus on exploratory data analysis. It also provides examples with more tools (particularly interactive ones) as well as recommending a clean code style. "],
["intro.html", "Chapter 3 Setup 3.1 Navigate R markdown quickly 3.2 Rstudio shortcuts 3.3 Load R packages to your library 3.4 The data to visualise 3.5 QA and Unit tests 3.6 Code style", " Chapter 3 Setup 3.1 Navigate R markdown quickly To quickly find part of your code to edit, instead of scrolling up and down the R Markdown code, jump instantly to the right section by using the document outline. You can show the outline in one of three ways: Hold down Ctrl+Shift+O. Click the top-right icon in the code pane. Left-click on the bottom bar of the R markdown file. The gif below shows these three methods. It’s recorded with ScreenToGif. I donated to the author as I found it so easy to use as well as providing lots of genuinely useful features - for example, a gif progress bar and the ability to pixelate out sections of the recording. 3.2 Rstudio shortcuts Another tip to speed up coding in RStudio is to use keyboard shortcuts. Here is the full list of RStudio shorcuts. I use Ctrl+Shift+M in Windows (Cmd+Shift+M in Mac) to insert a pipe %&gt;% with spaces which makes tidyverse coding fast. I also use Alt+- in Windows (Option+- in Mac) to create the assign operator &lt;-. 3.3 Load R packages to your library Here are all the R packages used in this book. # data vis https://www.htmlwidgets.org/index.html library(ggplot2) # static charts - amazing variety library(plotly) # interactive charts library(apexcharter) # much like the paid for highchater js library. Powerful library(trelliscopejs) # small multiples library(dygraphs) # awesome interactive timeseries # ggplot extensions https://www.ggplot2-exts.org/gallery/ library(scales) # improve your scales library(gganimate) # animate your ggplot library(png) # library(directlabels) # for directly labelling lines for example library(gghighlight) # label points of interest on your charts library(ggrepel) # move labels so they don&#39;t overlap library(glue) # include column names in a looping chart title library(crosstalk) # link html widgets like plotly to DT tables library(skimr) # quickly skim the characteristics of a data frame library(cowplot) # # colours library(RColorBrewer) # ready to use colour pallets library(prismatic) # palettes and ways to tweak an entire pallete # tables library(kableExtra) # attractive static tables library(formattable) # colour tables. Like Excel&#39;s conditional formattinng library(rpivotTable) # like Excel&#39;s pivot table library(DT) # awesome interactive tables library(reactable) # Quality Assurance library(tidylog) # great for QA on the fly library(testthat) # for writing unit tests library(assertr) # for writing tests verify assumptions about data early in the data pipeline of manipulation # wrangling / munging / manipulating library(tidyverse) # loads of useful packages in one # time series tools library(anytime) # convert text into the right date type library(tsbox) # convert to time series for dygraphs # sample data library(mosaicData) # sample data library(eventdataR) # sample process mining data sets # Processing mining library(bupaR) # the process mining package that converts your data into an event log library(edeaR) # good for filtering and subsetting a process event log library(processmapR) # convert an event log into a visual process map library(processanimateR) # animate a process map library(processcheckR) # carry out conformance checking (i.e. a process follows certain rules) library(heuristicsmineR) # Process discovery algorithm library(fuzzymineR) # Process discovery algorithm 3.4 The data to visualise Often in EDA and data visualisation, we are most interested in how values change over time. For example, are things getting worse, better, higher, lower? For this reason, instead of using a built in data set like iris or mtcars we mostly use the Texas housing sales data in this book. This is a time-series data set built into ggplot. To improve your skills I recommend finding other open data sets to develop your data vis skills. I found the marriage data we look at later in this comprehensive list of R datasets. The Tidy Tuesday data sets are also a great source of data sets. You also get to learn from seeing how others (including David Robinson) have tackled them. You could also look for data stories that interest you or that you could improve and explore further. I recently saw a data visualisation in The Times newspaper on smoking and vaping that I tried to improve. The only manipulation we will do to the Texas housing sales data below is to create a real date using lubridate. This book doesn’t cover the data manipulation part of EDA. A good guide is the Managing Data Frames with the dplyr package chapter in Roger Peng’s Exploratory Data Analysis with R. As well as the resources described in bullet 1 here. # create a data frame with a real date for plotting df &lt;- ggplot2::txhousing %&gt;% dplyr::mutate(date = lubridate::make_date(year = year, month = month, day =1)) Here are the top few rows of the data frame we created using a simple kableExtra table. The Tables chapter later on in this book describes different table methods in more detail. kableExtra::kable(utils::head(df)) city year month sales volume median listings inventory date Abilene 2000 1 72 5380000 71400 701 6.3 2000-01-01 Abilene 2000 2 98 6505000 58700 746 6.6 2000-02-01 Abilene 2000 3 130 9285000 58100 784 6.8 2000-03-01 Abilene 2000 4 98 9730000 68600 785 6.9 2000-04-01 Abilene 2000 5 141 10590000 67300 794 6.8 2000-05-01 Abilene 2000 6 156 13910000 66900 780 6.6 2000-06-01 3.5 QA and Unit tests 3.5.1 tidylog We’ll also use tidylog with dplyr. Tidylog is an easy way to include fast basic Quality Assurance during dplyr data manipulation. Just replace the dplyr verbs with the same verb in tidylog. Tidylog tells you what each dplyr verb has done to your data. For example, how many rows dplyr::filter() drops or adds, or what percentage of values dplyr::mutate() has changed. # create a data frame with a real date for plotting df &lt;- ggplot2::txhousing %&gt;% tidylog::mutate(date = lubridate::make_date(year = year, month = month, day =1)) ## mutate: changed 8,602 values (100%) of &#39;date&#39; (0 new NA) The tidylog message above tells us that the mutate has changed (100%) of 'date' (0 new NA). This is what we would expect to happen. Let’s also create a data frame with fewer cities so that some plots created later will be less crowded. Below we select only cities where the maximum number of sales in any month is more than 500. # reduce the number of cities for simpler plots df_red &lt;- df %&gt;% dplyr::group_by(city) %&gt;% tidylog::mutate(sales_max = base::max(sales)) %&gt;% dplyr::ungroup() %&gt;% tidylog::filter(sales_max &gt;= 500) ## mutate (grouped): new variable &#39;sales_max&#39; with 27 unique values and 43% NA ## filter: removed 6,171 rows (72%), 2,431 rows remaining Hold on. Look! Read the tidylog message above. It says new variable 'sales_max' with 27 unique values and 43% NA. As we filter the rows in the next line of code by sales_max we don’t want any of the values to be NA. Well spotted tidylog. We correct it below by removing NAs from salses_max by adding na.rm = TRUE inside the base:max() function. # reduce the number of cities for simpler plots df_red &lt;- df %&gt;% dplyr::group_by(city) %&gt;% tidylog::mutate(sales_max = base::max(sales, na.rm = TRUE)) %&gt;% dplyr::ungroup() %&gt;% tidylog::filter(sales_max &gt;= 500) ## mutate (grouped): new variable &#39;sales_max&#39; with 45 unique values and 0% NA ## filter: removed 5,984 rows (70%), 2,618 rows remaining The tidylog message above now tells us that the new variable sales_max has 0% NA as we would expect. 3.5.2 testthat Unit testing is mostly used during the creation of R packages. It can also be part of your analysis code. Particularly if your work is high impact and you need to be confident the results are still valid in the future. For example, you are running new data through your code or when you have added new logic. Unit tests are an automatic way to highlight errors new data or new logic has introduced you may not have spotted. Hadley Wickham provides some useful “what to test” rules of thumb for when to use unit tests in his R packages book: Strive to test each behaviour in one and only one test. Then if that behaviour later changes you only need to update a single test. Avoid testing simple code that you’re confident will work. Instead focus your time on code that you’re not sure about, is fragile, or has complicated interdependencies. That said, I often find I make the most mistakes when I falsely assume that the problem is simple and doesn’t need any tests. Always write a test when you discover a bug. You may find it helpful to adopt the test-first philosophy. There you always start by writing the tests, and then write the code that makes them pass. This reflects an important problem solving strategy: start by establishing your success criteria, how you know if you’ve solved the problem. In this unit test we’re immediately going to break Hadley’s second rule above and write a test on the simple code that created our dataframe df. The unit tests are all adapted from an excellent introductory blog on unit tests. The code has been altered to follow the three Code style rules described in the next chapter to make these examples easier to read and understand. First, let’s test if the dimensions of df are as we expect with 9 columns and 8,602 rows. testthat::test_that(&quot;data dimensions correct&quot;, { testthat::expect_equal( object = base::ncol(df), expected = 9 ) testthat::expect_equal( object = base::nrow(df), expected = 8602 ) }) This testthat::test_that() test does not return a message, so we know df has passed because the dimensions are as we expect. Let’s now test data types. testthat::test_that(&#39;data types correct&#39;, { testthat::expect_is(object = df, class = &#39;data.frame&#39;) testthat::expect_is(object = df$date, class = &#39;Date&#39;) }) Again, this test no messages so df has passed this test. Finally, let’s run a test we know will fail to see what failure message returns. testthat::test_that(&quot;no missing values&quot;, { testthat::expect_identical( object = df, expected = stats::na.omit(df) ) }) ## Error: Test failed: &#39;no missing values&#39; ## * &lt;text&gt;:3: `df` not identical to stats::na.omit(df). ## Different number of rows The code above tests if the original df object is identical to the expected object after omitting rows with NA values (using stats::na.omit()). The testthat message tells us the object and the expectation have a Different number of rows. We can now investigate this test failure by eye-balling some rows of df where any of the columns contain a missing value. Then decide if this is what we would expect from this data source. df %&gt;% dplyr::filter_all(dplyr::any_vars(base::is.na(.))) %&gt;% utils::head() %&gt;% kableExtra::kable() city year month sales volume median listings inventory date Abilene 2006 3 155 18030000 105400 NA NA 2006-03-01 Amarillo 2005 10 67 7225000 87000 NA NA 2005-10-01 Amarillo 2006 6 345 46755000 120700 NA NA 2006-06-01 Amarillo 2006 9 288 37365000 114100 NA NA 2006-09-01 Amarillo 2007 11 253 32910000 114800 NA NA 2007-11-01 Amarillo 2010 5 333 45797490 122100 NA NA 2010-05-01 3.5.3 assertr You can also run tests piped directly within your data manipulation code using assertr. This assertr vignette has good examples on built-in data, as well as the assert section at the bottom of this good blog. Below we purposely ensure the assertr tests will fail all the tests so we can read the useful error output it can create. df %&gt;% assertr::chain_start() %&gt;% assertr::verify(base::nrow(.) == 8601) %&gt;% assertr::verify(base::ncol(.) ==8) %&gt;% assertr::assert(in_set(1:11), month) %&gt;% assertr::assert(in_set(2000:2014), year) %&gt;% assertr::assert(within_bounds(lower.bound = 0, upper.bound = Inf, include.lower= TRUE, allow.na = TRUE), -city,-date) %&gt;% assertr::insist(within_n_sds(3), sales:inventory,) %&gt;% assertr::assert(not_na, dplyr::everything()) %&gt;% assertr::chain_end(error_fun = error_stop) ## verification [base::nrow(.) == 8601] failed! (1 failure) ## ## verb redux_fn predicate column index value ## 1 verify NA base::nrow(.) == 8601 NA 1 NA ## ## verification [base::ncol(.) == 8] failed! (1 failure) ## ## verb redux_fn predicate column index value ## 1 verify NA base::ncol(.) == 8 NA 1 NA ## ## Column &#39;month&#39; violates assertion &#39;in_set(1:11)&#39; 690 times ## verb redux_fn predicate column index value ## 1 assert NA in_set(1:11) month 12 12 ## 2 assert NA in_set(1:11) month 24 12 ## 3 assert NA in_set(1:11) month 36 12 ## 4 assert NA in_set(1:11) month 48 12 ## 5 assert NA in_set(1:11) month 60 12 ## [omitted 685 rows] ## ## ## Column &#39;year&#39; violates assertion &#39;in_set(2000:2014)&#39; 322 times ## verb redux_fn predicate column index value ## 1 assert NA in_set(2000:2014) year 181 2015 ## 2 assert NA in_set(2000:2014) year 182 2015 ## 3 assert NA in_set(2000:2014) year 183 2015 ## 4 assert NA in_set(2000:2014) year 184 2015 ## 5 assert NA in_set(2000:2014) year 185 2015 ## [omitted 317 rows] ## ## ## Column &#39;sales&#39; violates assertion &#39;within_n_sds(3)&#39; 288 times ## verb redux_fn predicate column index value ## 1 insist NA within_n_sds(3) sales 2060 4244 ## 2 insist NA within_n_sds(3) sales 2061 3977 ## 3 insist NA within_n_sds(3) sales 2062 4545 ## 4 insist NA within_n_sds(3) sales 2063 4738 ## 5 insist NA within_n_sds(3) sales 2064 4276 ## [omitted 283 rows] ## ## ## Column &#39;volume&#39; violates assertion &#39;within_n_sds(3)&#39; 254 times ## verb redux_fn predicate column index value ## 1 insist NA within_n_sds(3) volume 722 944924177 ## 2 insist NA within_n_sds(3) volume 723 880058970 ## 3 insist NA within_n_sds(3) volume 724 993168216 ## 4 insist NA within_n_sds(3) volume 725 931481472 ## 5 insist NA within_n_sds(3) volume 734 1012123948 ## [omitted 249 rows] ## ## ## Column &#39;median&#39; violates assertion &#39;within_n_sds(3)&#39; 89 times ## verb redux_fn predicate column index value ## 1 insist NA within_n_sds(3) median 734 243900 ## 2 insist NA within_n_sds(3) median 735 248900 ## 3 insist NA within_n_sds(3) median 736 246900 ## 4 insist NA within_n_sds(3) median 737 243800 ## 5 insist NA within_n_sds(3) median 740 242100 ## [omitted 84 rows] ## ## ## Column &#39;listings&#39; violates assertion &#39;within_n_sds(3)&#39; 255 times ## verb redux_fn predicate column index value ## 1 insist NA within_n_sds(3) listings 2086 21153 ## 2 insist NA within_n_sds(3) listings 2087 22043 ## 3 insist NA within_n_sds(3) listings 2088 23165 ## 4 insist NA within_n_sds(3) listings 2089 23056 ## 5 insist NA within_n_sds(3) listings 2090 23551 ## [omitted 250 rows] ## ## ## Column &#39;inventory&#39; violates assertion &#39;within_n_sds(3)&#39; 187 times ## verb redux_fn predicate column index value ## 1 insist NA within_n_sds(3) inventory 3108 21.9 ## 2 insist NA within_n_sds(3) inventory 3109 23.2 ## 3 insist NA within_n_sds(3) inventory 3115 22.8 ## 4 insist NA within_n_sds(3) inventory 3118 21.9 ## 5 insist NA within_n_sds(3) inventory 3119 22.0 ## [omitted 182 rows] ## ## ## Column &#39;sales&#39; violates assertion &#39;not_na&#39; 568 times ## verb redux_fn predicate column index value ## 1 assert NA not_na sales 1144 NA ## 2 assert NA not_na sales 1159 NA ## 3 assert NA not_na sales 1160 NA ## 4 assert NA not_na sales 1161 NA ## 5 assert NA not_na sales 1162 NA ## [omitted 563 rows] ## ## ## Column &#39;volume&#39; violates assertion &#39;not_na&#39; 568 times ## verb redux_fn predicate column index value ## 1 assert NA not_na volume 1144 NA ## 2 assert NA not_na volume 1159 NA ## 3 assert NA not_na volume 1160 NA ## 4 assert NA not_na volume 1161 NA ## 5 assert NA not_na volume 1162 NA ## [omitted 563 rows] ## ## ## Column &#39;median&#39; violates assertion &#39;not_na&#39; 616 times ## verb redux_fn predicate column index value ## 1 assert NA not_na median 1144 NA ## 2 assert NA not_na median 1159 NA ## 3 assert NA not_na median 1160 NA ## 4 assert NA not_na median 1161 NA ## 5 assert NA not_na median 1162 NA ## [omitted 611 rows] ## ## ## Column &#39;listings&#39; violates assertion &#39;not_na&#39; 1424 times ## verb redux_fn predicate column index value ## 1 assert NA not_na listings 75 NA ## 2 assert NA not_na listings 257 NA ## 3 assert NA not_na listings 265 NA ## 4 assert NA not_na listings 268 NA ## 5 assert NA not_na listings 282 NA ## [omitted 1419 rows] ## ## ## Column &#39;inventory&#39; violates assertion &#39;not_na&#39; 1467 times ## verb redux_fn predicate column index value ## 1 assert NA not_na inventory 75 NA ## 2 assert NA not_na inventory 257 NA ## 3 assert NA not_na inventory 265 NA ## 4 assert NA not_na inventory 268 NA ## 5 assert NA not_na inventory 282 NA ## [omitted 1462 rows] ## Error: assertr stopped execution Then we adjust all of the tests so that they pass. df %&gt;% assertr::chain_start() %&gt;% assertr::verify(base::nrow(.) == 8602) %&gt;% assertr::verify(base::ncol(.) ==9) %&gt;% assertr::assert(in_set(1:12), month) %&gt;% assertr::assert(in_set(2000:2015), year) %&gt;% assertr::assert(within_bounds(lower.bound = 0, upper.bound = Inf, include.lower= TRUE, allow.na = TRUE), -city,-date) %&gt;% assertr::insist(within_n_sds(11), sales:inventory,) %&gt;% #assertr::assert(not_na, dplyr::everything()) %&gt;% assertr::chain_end(error_fun = error_stop) %&gt;% utils::head() ## # A tibble: 6 x 9 ## city year month sales volume median listings inventory date ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;date&gt; ## 1 Abilene 2000 1 72 5380000 71400 701 6.3 2000-01-01 ## 2 Abilene 2000 2 98 6505000 58700 746 6.6 2000-02-01 ## 3 Abilene 2000 3 130 9285000 58100 784 6.8 2000-03-01 ## 4 Abilene 2000 4 98 9730000 68600 785 6.9 2000-04-01 ## 5 Abilene 2000 5 141 10590000 67300 794 6.8 2000-05-01 ## 6 Abilene 2000 6 156 13910000 66900 780 6.6 2000-06-01 The code above returns the data frame which means assertr code could be part of your data preparation code when df was created. df &lt;- ggplot2::txhousing %&gt;% dplyr::mutate(date = lubridate::make_date(year = year, month = month, day =1)) %&gt;% assertr::chain_start() %&gt;% assertr::verify(base::nrow(.) == 8602) %&gt;% assertr::verify(base::ncol(.) ==9) %&gt;% assertr::assert(in_set(1:12), month) %&gt;% assertr::assert(in_set(2000:2015), year) %&gt;% assertr::assert(within_bounds(lower.bound = 0, upper.bound = Inf, include.lower= TRUE, allow.na = TRUE), -city,-date) %&gt;% assertr::insist(within_n_sds(11), sales:inventory,) %&gt;% #assertr::assert(not_na, dplyr::everything()) %&gt;% assertr::chain_end(error_fun = error_stop) 3.6 Code style 3.6.1 Rule 1: Include names before all functions Include the package name before every function, even for base R functions, to make your code easier to read, I started learning R by reading other people’s code. But I got confused where functions came from. Particularly when they used functions from lots of different packages mixed with base functions and their own functions, but without the package name shown. It made their code appear more complicated and intimidating than it was. Another benefit of including the package name is hitting the tab key at the end of the double colon let’s us browse all the package’s functions in a scrollable list. Also, try highlighting a function and its package name then hit the F1 key to show the help page. While hitting the F2 key can be a quick way to see all the possible arguments in a function. As well as seeing the default argument values the package author has chosen for you. 3.6.2 Rule 2: Add argument names to all functions Instead of relying on the order of the arguments the function expects, name every argument when you set its value. Your code will be quicker to understand when we know which arguments are set without having to read the help page for that function. 3.6.3 Rule 3: Each line does one thing Each line of code should do one thing. You can do this by hitting the return key after every pipe %&gt;%, comma, or plus +. RStudio will then automatically indent your code in just the right way. You can also indent old code by blocking on to it and using the RStudio shorcut Ctrl+Shift+A in Windows (Command+Shift+A in Mac). The code below works but doesn’t follow the three rules. It is cramped, slow to understand, and can be difficult to edit or re-use. ggplot(df) + geom_line(aes(date,sales, colour = city)) + ggplot2::theme_minimal() + gghighlight(max(sales) &gt; 5000, label_params = list(size = 4)) + scale_y_continuous(labels = scales::comma) + scale_x_date(date_breaks = &quot;1 year&quot;, labels = scales::date_format(&quot;%d %b %y&quot;), limits = c(as.Date(&quot;2000-01-01&quot;), as.Date(&quot;2015-07-01&quot;))) + labs(title = &quot;US Housing Sales over time&quot;, subtitle = &quot;US cities with more than 5k sales in a month&quot;, caption = &quot;Source: ggplot2 package demo data&quot;) + geom_vline(xintercept = years, linetype = 4) + theme(panel.grid.major.x = element_blank(), panel.grid.minor.x = element_blank(), strip.text.x = element_text(size = 10), axis.text.x = element_text(angle = 60, hjust = 1, size = 9), legend.text = element_text(size = 12), legend.position = &quot;right&quot;, legend.direction = &quot;vertical&quot;, plot.title = element_text(size = 22, face = &quot;bold&quot;), plot.subtitle = element_text(color = &quot;grey&quot;, size = 18), plot.caption = element_text(hjust = 0, size = 12, color = &quot;darkgrey&quot;), legend.title = element_blank()) In contrast, the code below is identical to the code above, but it follows the three rules so you can more easily: Run your code top downwards in chunks adding more lines each time. Much like the popular ggplot flip-books I describe at bullet 11 in my collection of R guides and galleries. Comment out one line of code (or just one argument in a function) to understand what it does when you run the code without it. Find and edit arguments in a function (e.g. a font size) Help others QA or re-use your code. Help others new to R understand what you are doing and learn faster. Avoid being a gatekeeper of your R knowledge and skills. Share, explain and democratise what you know. You can then move on to more sophisticated analysis in R with an even higher value. Richard Susskind advocates this in The Future of Professions) and in my example of describing NLP techniques intuitively. Further tweaks to improve code clarity are to put spaces either side of the equals sign and to use styler to apply some of these rules automatically. You can also customise styler to apply your own rules. I want to try customising styler to apply rules 1 to 3 above. I don’t know if that’s possible yet. df %&gt;% ggplot2::ggplot() + ggplot2::aes( x = date, y = sales, colour = city ) + ggplot2::geom_line() + ggplot2::theme_minimal() + gghighlight::gghighlight(max(sales) &gt; 5000, label_params = list(size = 4) ) + ggplot2::scale_y_continuous(labels = scales::comma) + ggplot2::scale_x_date( date_breaks = &quot;1 year&quot;, labels = scales::date_format(&quot;%d %b %y&quot;), limits = c( as.Date(&quot;2000-01-01&quot;), as.Date(&quot;2015-07-01&quot;) ) ) + ggplot2::labs( title = &quot;US Housing Sales over time&quot;, subtitle = &quot;US cities with more than 5k sales in a month&quot;, caption = &quot;Source: ggplot2 package demo data&quot; ) + ggplot2::geom_vline( xintercept = years, linetype = 4 ) + ggplot2::theme( panel.grid.major.x = element_blank(), panel.grid.minor.x = element_blank(), strip.text.x = element_text(size = 10), axis.text.x = element_text( angle = 60, hjust = 1, size = 9 ), legend.text = element_text(size = 12), legend.position = &quot;right&quot;, legend.direction = &quot;vertical&quot;, plot.title = element_text( size = 22, face = &quot;bold&quot; ), plot.subtitle = element_text( color = &quot;grey&quot;, size = 18 ), plot.caption = element_text( hjust = 0, size = 12, color = &quot;darkgrey&quot; ), legend.title = element_blank() ) Note this layout differs from the layered grammar of graphics code template below. ggplot(data = &lt;DATA&gt;) + &lt;GEOM_FUNCTION&gt;( mapping = aes(&lt;MAPPINGS&gt;), stat = &lt;STAT&gt;, position = &lt;POSITION&gt; ) + &lt;COORDINATE_FUNCTION&gt; + &lt;FACET_FUNCTION&gt; My preference is for the code style to let you imagine data being “poured” into ggplot through the pipe. Then we tell ggplot which columns to map, then the geom, followed by the same co-ordinate and facet functions as Wickham recommends. This is inspired by the code layout of the many flipbook guides (see bullet 11 here for examples). &lt;DATA&gt; %&gt;% ggplot2::ggplot() + ggplot2::aes(&lt;MAPPINGS&gt;) + ggplot2::&lt;GEOM_FUNCTION&gt;( stat = &lt;STAT&gt;, position = &lt;POSITION&gt; ) + &lt;COORDINATE_FUNCTION&gt; + &lt;FACET_FUNCTION&gt; "],
["exploratory-data-analysis.html", "Chapter 4 Exploratory Data Analysis 4.1 Start with dplyr counts and summaries in console 4.2 Plot data points with geom_point() 4.3 Facet by categories 4.4 Facet interactively (trelliscopejs) 4.5 Loop to plot every category separately 4.6 Polish your final plot 4.7 Simplify plot theme settings", " Chapter 4 Exploratory Data Analysis 4.1 Start with dplyr counts and summaries in console In his Tidy Tuesday live coding videos, David Robinson usually starts exploring new data with dplyr::count() in the console. I recommend this as the first step in your EDA. In the code below we don’t use the package name in the console (so breaking rule 1 I just told you). We don’t need the package name as we won’t save this code for others to read. This means we can type more quickly to explore the data with dplyr verbs faster. df %&gt;% count(city) %&gt;% View() df %&gt;% count(city, year, month) %&gt;% View()# df %&gt;% group_by(city) %&gt;% summarise(vol_max = max(volume, na.rm = T)) %&gt;% arrange(desc(vol_max)) %&gt;% View() 4.2 Plot data points with geom_point() After using dplyr::count(), dplyr::group_by() and dplyr::summarise(), try plotting the data points with ggplot2::geom_point(). It almost NEVER fails to show you what’s going on quickly. And it is unlikely to return a confusing ggplot error message. ggplot2::geom_point() is the minimum and most reliable ggplot plot type (or geom) to start visualising data. Increasingly, I’m finding ggpplot2::geom_point() is often a good choice to include in the final pot too. Let’s look at all the values of sales for each date. df %&gt;% ggplot2::ggplot() + ggplot2::aes( x = date, y = sales ) + ggplot2::geom_point() ## Warning: Removed 568 rows containing missing values (geom_point). Now let’s look at the individual sales values for each city. df %&gt;% ggplot2::ggplot() + ggplot2::aes( x = sales, y = city ) + ggplot2::geom_point() ## Warning: Removed 568 rows containing missing values (geom_point). With so many data points to plot they overlap to create thick dark lines that might hide interesting variation. This is known as overplotting. Reduce over plotting by replacing ggplot2::geom_point() with ggplot2::geom_jitter(). It randomly jitters the location of the data points by a small amount so that fewer points overlap. Sometimes there are so many data points that jittering does not reduce overplotting enough. You can also make the data points lighter using the alpha argument of ggplot2::geom_jitter() as in the code below. The lower the value of alpha the fainter the points. df %&gt;% ggplot2::ggplot() + ggplot2::aes( x = sales, y = city ) + ggplot2::geom_jitter(alpha = 0.01) ## Warning: Removed 568 rows containing missing values (geom_point). Hadley Wickham has a few more tricks you can use in the free to access overplotting chapter of his ggplot2: Elegant Graphics for Data Analysis book. We all know sales of most things vary by the time of year. So let’s now put date on the x-axis, make city the colour, and because the data is over time we can join the data points by using ggplot2::geom_line(). We also use the reduced dataframe with fewer cities to create a less crowded plot. df_red %&gt;% ggplot2::ggplot() + ggplot2::aes( x = date, y = sales, colour = city ) + ggplot2::geom_line() ## Warning: Removed 1 rows containing missing values (geom_path). Beautiful. While sales have very different volumes between cities, we can see they all follow a similar same seasonal pattern. To bring the trends of sales closer to each other so that they are easier to compare, we can transform the sales value by showing the log of sales. This is Hadley Wickham’s approach in ggplot2: Elegant Graphics for Data Analysis. Wickham goes on to model the Texas housing sales data by fitting a linear model between the log of sales and the month. He then plots the residuals (i.e. the change in sales not explained by the month) to remove the strong seasonal effects, similar to decomposition in a classic time series analysis. Take a look at the new fable forecasting package for another way to decompose a time series. We take a visual approach to reduce the seasonal effect in the final Polish your final plot part of this chapter. We plot the entire time series with years marked so that you can easily see the strong repeating monthly sales pattern. df_red %&gt;% ggplot2::ggplot() + ggplot2::aes( x = date, y = base::log(sales), colour = city ) + ggplot2::geom_line() ## Warning: Removed 1 rows containing missing values (geom_path). 4.3 Facet by categories So far we have shown the different sales patterns for each city by putting city into the colour argument of ggplot. However, with lots of cities, the plot gets too crowded. When you have many categories to compare like this, then facets or “small multiples” are the right choice. In other words, draw a chart for each value in one or more columns then look at all the plots at once, usually in a grid. Also, consider setting the scales argument of the facet to \"free\" like this scales = \"free\". Each plot will then have its scale set to the maximum of each city’s sales. It lets us more easily spot interesting differences or similarities in the patterns over time between each city. df_red %&gt;% ggplot2::ggplot() + ggplot2::aes( x = date, y = sales, colour = city ) + ggplot2::geom_line() + ggplot2::facet_wrap(~city, scales = &quot;free&quot; ) ## Warning: Removed 1 rows containing missing values (geom_path). 4.4 Facet interactively (trelliscopejs) You can also facet and explore your data interactively with a GUI using trelliscopejs piped onto the end of your ggplot. Below we facet all the Texas cities in a trelliscopejs web page. Have a play with all the settings in the chart below to see what it does. df %&gt;% ggplot2::ggplot() + ggplot2::aes( x = date, y = sales ) + ggplot2::geom_line() + trelliscopejs::facet_trelliscope(~city, scales = &quot;free&quot;, nrow = 3, ncol = 5, self_contained = TRUE, # as_plotly = TRUE, # not working plotly_cfg = list(displayModeBar = FALSE) ) 4.5 Loop to plot every category separately To study each city as a full single chart on its own we can loop through the cities and plot them automatically with very little code. To do this we “nest” a dataframe for each city into one dataframe. Then loop through each of the nested city dataframes, creating a plot for each one. Here we use dplyr::group_by() on city, then use tidyr::nest() to create the individual nested dataframes. df_red_nest &lt;- df_red %&gt;% dplyr::group_by(city) %&gt;% tidyr::nest() If we pipe the nested dataframe df_red_nest into View() this lets us see the individual dataframes contained within the data column that tidyr::nest() has created. df_red_nest %&gt;% View() We can also view one of the nested data frames using square brackets. Think of the numbers in the square brackets like the coordinates in Excel. The first number is the column position, and the second number is the row position. In the example below we view the second column along of the nested dataframe [[2]] and the first row of that column [[1]]. df_red_nest[[2]][[1]] %&gt;% View() Once you start to get comfortable with how square brackets work, it is a powerful way to navigate through nested R objects. The code above showed us the data in the first nested data frame of one city. The code below now drills down into the first column and first row of that single nested dataframe. This is just one cell, so is the most granular drill down possible for the object df_red_nest. df_red_nest[[2]][[1]][[1]][[1]] %&gt;% View() We can now add a plot to each nested data frame for each city. We use purrr::map2(). This purr function is a compact way to loop through two arguments in another function. The function arguments of ggplot2::ggplot() being set by purrr::map2() are the .x and .y values. They are the nested dataframes in the data column, and the city names inside the city column of the nested dataframe df_red_nest respectively. df_red_nest &lt;- df_red_nest %&gt;% dplyr::mutate(plot = purrr::map2(.x = data, .y = city, ~ ggplot2::ggplot(data = .x, aes(x = date, y = sales)) + ggtitle(glue::glue(&quot;Plot of {.y}&quot;)) + geom_line())) Take a look at the new nested data frame with a new column added containing a plot for each city. df_red_nest %&gt;% View() Let’s also look at the information held for one of the plots, again using values in square brackets. The code below shows you that the plot is a series of nested lists that describe every element of the plot. df_red_nest[[3]][[1]] %&gt;% View() Finally, let’s print every plot with this simple code. Show all the looped prints base::print(df_red_nest$plot) ## [[1]] ## ## [[2]] ## ## [[3]] ## ## [[4]] ## ## [[5]] ## Warning: Removed 1 rows containing missing values (geom_path). ## ## [[6]] ## ## [[7]] ## ## [[8]] ## ## [[9]] ## ## [[10]] ## ## [[11]] ## ## [[12]] ## ## [[13]] ## ## [[14]] 4.6 Polish your final plot We now have a bare minimum Exploratory Data Analysis toolkit. We explore the data with dplyr::count() from the console then visualise it with ggplot2::geom_point(). From exploring the data quickly we are soon ready to select a plot that tells a compelling story. But adding all the bells and whistles to make the final plot for a customer or publication can and does take a long time. So this polish shouldn’t be part of your exploratory data analysis. Also, make sure your polished plot code follows the Code style recommended earlier. You will find it quicker to comment out or tweak specific parts of your plot code until it looks just right. Clean code is faster to iterate. The plot below isn’t perfect. There may be things you want to change depending both on what story you want to tell and your style. How did I write this code? By Googling for what I wanted to do (e.g. “ggplot remove axis grid lines”), copying the code from a stackoverflow answer, then pasting the code into a clear structure as below. Many of the tweaks or polish will be to ggplot2::theme() or ggplot2::scale() but are you really going to remember the ggplot code you need for every adjustment you want to make? I no longer worry about remembering how to do it and focus on how I want it to look and get absorbed in the creation and satisfaction of the plot gradually improving. After you have built a few of your publication-quality pots with clear code, you will soon be using your plot code as a store of examples to re-use meaning that you will Google less. Be prepared for this code tweaking and plot polishing to take longer than you planned. Always. # a list of dates to add vertical lines to the plot years &lt;- base::seq.Date( from = as.Date(&quot;2000-01-01&quot;), to = as.Date(&quot;2015-01-01&quot;), by = &quot;years&quot; ) p &lt;- df %&gt;% ggplot2::ggplot() + ggplot2::aes( x = date, y = sales, colour = city ) + ggplot2::geom_line(size = 1) + gghighlight::gghighlight(base::max(sales) &gt; 5000, # highlight only cities with higher sales label_params = list(size = 4) ) + ggplot2::scale_y_continuous(labels = scales::comma) + ggplot2::scale_x_date( date_breaks = &quot;1 year&quot;, labels = scales::date_format(&quot;%b %y&quot;), limits = c( as.Date(&quot;2000-01-01&quot;), as.Date(&quot;2015-07-01&quot;) ) ) + ggplot2::labs( title = &quot;Texas Housing Sales&quot;, subtitle = &quot;Texas cities with more than 5,000 sales in any month&quot;, caption = &quot;Source: ggplot2 built in txhousing data set&quot;, x = &quot;Month&quot;, y = &quot;Volume of Sales&quot; ) + ggplot2::geom_vline( xintercept = years, linetype = 4 ) + ggplot2::theme_minimal() + ggplot2::theme( panel.grid.major.x = element_blank(), panel.grid.minor.x = element_blank(), strip.text.x = element_text(size = 10), axis.text.x = element_text( angle = 60, hjust = 1, size = 9 ), plot.title = element_text( size = 22, face = &quot;bold&quot; ), plot.subtitle = element_text( color = &quot;grey&quot;, size = 18 ), plot.caption = element_text( hjust = 0, size = 12, color = &quot;darkgrey&quot; ), ) ## label_key: city ggplot2::ggsave(file=&quot;texas.svg&quot;, device = &quot;svg&quot;, plot=p) ## Saving 7 x 5 in image ## Warning: Removed 430 rows containing missing values (geom_path). 4.7 Simplify plot theme settings If we’re happy with the font sizes and other theme settings in our final plot we will want further plots to look the same. We can so this with less code by creating our own theme then setting that as the default using ggplot2::theme_set(). Defining the plot theme settings separately will make our plot code shorter and so easier to read. Below we put all the plot theme settings from the final plot above into my_theme then set that as the default. my_theme &lt;- ggplot2::theme_minimal() + ggplot2::theme( panel.grid.major.x = element_blank(), panel.grid.minor.x = element_blank(), strip.text.x = element_text(size = 10), axis.text.x = element_text( angle = 60, hjust = 1, size = 9 ), plot.title = element_text( size = 22, face = &quot;bold&quot; ), plot.subtitle = element_text( color = &quot;grey&quot;, size = 18 ), plot.caption = element_text( hjust = 0, size = 12, color = &quot;darkgrey&quot; ), ) # Set my_theme to be the default ggplot2::theme_set(my_theme) We can now run our final plot again but without any theme settings. The plot uses the default theme we have set above and so looks the same. With shorter code we can more quickly understand what it is doing. df %&gt;% ggplot2::ggplot() + ggplot2::aes( x = date, y = sales, colour = city ) + ggplot2::geom_line(size = 1) + gghighlight::gghighlight(base::max(sales) &gt; 5000, # highlight only cities with higher sales label_params = list(size = 4) ) + ggplot2::scale_y_continuous(labels = scales::comma) + ggplot2::scale_x_date( date_breaks = &quot;1 year&quot;, labels = scales::date_format(&quot;%b %y&quot;), limits = c( as.Date(&quot;2000-01-01&quot;), as.Date(&quot;2015-07-01&quot;) ) ) + ggplot2::labs( title = &quot;Texas Housing Sales&quot;, subtitle = &quot;Texas cities with more than 5,000 sales in any month&quot;, caption = &quot;Source: ggplot2 built in txhousing data set&quot;, x = &quot;Month&quot;, y = &quot;Volume of Sales&quot; ) + ggplot2::geom_vline( xintercept = years, linetype = 4 ) ## label_key: city ## Warning: Removed 430 rows containing missing values (geom_path). "],
["why-start-with-geom-point.html", "Chapter 5 Why start with geom_point() ? 5.1 ggplot is famed for annoying errors 5.2 Retreat to geom_point() 5.3 geom_jitter() and geom_boxplot() is better 5.4 Final choice: geom_dotplot() and stat_summary()", " Chapter 5 Why start with geom_point() ? 5.1 ggplot is famed for annoying errors It’s a good idea to start with ggplot2::geom_point() because it works for both raw and summarised data straight away. This both speeds up EDA and makes ggplot less intimidating for beginners. Let’s explore more granular data to trigger some common errors using the marriage data from the mosaicData package. We do a little data cleaning on the ceremony date and on the column that describes any previous marriages. marriage &lt;- mosaicData::Marriage %&gt;% tidylog::mutate(prev_marriage = as.character(prevconc)) %&gt;% tidylog::mutate(prev_marriage = case_when( is.na(prev_marriage) ~ &quot;First Time&quot;, TRUE ~ prev_marriage )) %&gt;% tidylog::mutate(ceremonydate1 = lubridate::parse_date_time(ceremonydate, &quot;mdy&quot;)) ## mutate: new variable &#39;prev_marriage&#39; with 3 unique values and 49% NA ## mutate: changed 48 values (49%) of &#39;prev_marriage&#39; (48 fewer NA) ## mutate: new variable &#39;ceremonydate1&#39; with 49 unique values and 0% NA kableExtra::kable(utils::head(marriage %&gt;% dplyr::select(ceremonydate1, person, prev_marriage, age, race, sign))) ceremonydate1 person prev_marriage age race sign 1996-11-09 Groom First Time 32.60274 White Aries 1996-11-12 Groom Divorce 32.29041 White Leo 1996-11-27 Groom Divorce 34.79178 Hispanic Pisces 1996-12-07 Groom Divorce 40.57808 Black Gemini 1996-12-14 Groom First Time 30.02192 White Saggitarius 1996-12-26 Groom First Time 26.86301 White Pisces In the Texas housing sales data, geom_line works because we have only one value of sales per city and date used in the “aesthetics” of the plot (e.g. x,y, colour, category, or facet being the most common aesthetics). A common way to trigger ggplot2 errors (or create confusing plots) is to use bar and line charts before the data is summarised. For example, a line chart is inappropriate with many ages per previous marriage status in the data. marriage %&gt;% ggplot2::ggplot() + ggplot2::aes( x = prev_marriage, y = age ) + ggplot2::geom_line() Changing the plot above to a bar chart instead returns a confusing error. marriage %&gt;% ggplot2::ggplot() + ggplot2::aes( x = prev_marriage, y = age ) + ggplot2::geom_bar() ## Error: stat_count() must not be used with a y aesthetic. ggplot2::geom_col() or ggplot2::geom_bar(stat = \"identity\") will plot the data for us without and error but it’s showing the sum of all the ages in each previous marriage category which doesn’t tell us an interesting story in the data. marriage %&gt;% ggplot2::ggplot() + ggplot2::aes( x = prev_marriage, y = age ) + ggplot2::geom_bar(stat = &quot;identity&quot;) #ggplot2::geom_col() Another reason to avoid starting EDA with bars is they may perform a statistical transformation without us realising. As explained in the Statistical Transformations chapter of R for Data Science. A bar or line may end up being the final plot choice, but for fast EDA let’s avoid them and retreat to our friend ggplot2::geom_point() 5.2 Retreat to geom_point() Let’s go back to using ggplot2::geom_point() and facet by person. marriage %&gt;% ggplot2::ggplot() + ggplot2::aes( x = prev_marriage, y = age ) + ggplot2::facet_wrap(~person) + ggplot2::geom_point(alpha = 0.3) Immediately this is the start of an interesting story we can follow. We see the ages of brides and grooms shown by whether they are getting married for the first time or if they have been divorced or widowed. As well as data points we might also experiment with different ways of showing these distributions. Hadley Wickham’s ggplot2: Elegant Graphics for Data Analysis has a good short chapter on displaying distributions. First let’s try a histogram and see if this helps us tell a good story. marriage %&gt;% ggplot2::ggplot() + ggplot2::aes(x = age) + ggplot2::facet_wrap(~ person + prev_marriage) + ggplot2::geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. We get a warning about the bin width. We can set the bin width by hand, say 6 bins. marriage %&gt;% ggplot2::ggplot() + ggplot2::aes(x = age) + ggplot2::facet_wrap(~ person + prev_marriage) + ggplot2::geom_histogram(bins = &quot;6&quot;) This looks better but is there an optimum bin number? There is probably no optimum width, as discussed in this stackexchange question. Let’s also try a density distribution plot using ggplot2::geom_density() p &lt;- marriage %&gt;% ggplot2::ggplot() + ggplot2::aes( x = age, fill = prev_marriage ) + ggplot2::geom_density(adjust = 1, alpha = 0.5, colour = NA) + ggplot2::facet_wrap(vars(person), ncol = 1) + ggplot2::theme_minimal() directlabels::direct.label(p, list(&quot;top.points&quot;, cex = .75, hjust = 0, vjust = -0.2)) 5.3 geom_jitter() and geom_boxplot() is better But with so few data points I think that ggplot2::box_plot() with the data points overlaid using ggplot2::geom_jitter() tells the data story well. marriage %&gt;% ggplot2::ggplot() + ggplot2::aes( x = prev_marriage, y = age ) + ggplot2::facet_wrap(~person) + ggplot2::geom_boxplot(alpha = 0.8) + ggplot2::geom_jitter(width = 0.1, alpha = 0.3) + ggplot2::theme_light() 5.4 Final choice: geom_dotplot() and stat_summary() The plot above would have been my final choice until I saw the fantastic “evolution of a ggplot” post by Cedric Sherer. In the gif below you can see Sherer also starts with a boxplot, but his final choice is ggplot2::geom_jitter() and ggplot2::stat_summary(). His post gives the full code in a gradual code story presented like the ggplot flip-books. And here is his final plot shown at the end of the looping gif above. Inspired by that plot and its code I prefer my final plot below on the marriage data. It is more engaging than a boxplot as it tells the story with little or no explanation needed. Much like a plot in a quality online newspaper can. I have also used ggplot2::geom_dotplot() instead of ggplot2::geom_jitter(). The dot plot lines up dots that very close in value. I found this geom_dotplot tutorial helpful to understand how to use it and control how the dots are lined up using the binwidth argument. p &lt;- marriage %&gt;% dplyr::group_by(person,prev_marriage) %&gt;% dplyr::mutate(pers_prev_avg = median(age)) %&gt;% dplyr::ungroup() %&gt;% dplyr::group_by(person) %&gt;% dplyr::mutate(pers_avg = median(age)) %&gt;% dplyr::ungroup() %&gt;% ggplot2::ggplot() + ggplot2::aes( x = prev_marriage, y = age, fill = prev_marriage, colour = prev_marriage, ) + ggplot2::facet_wrap(~person, ncol = 1) + ggplot2::stat_summary(fun.y = median, geom = &quot;point&quot;, size = 4, alpha = 0.8) + ggplot2::stat_summary(aes(label= paste( round(..y..,1), &quot; years&quot;)), fun.y=median, colour = &quot;black&quot;, geom=&quot;text&quot;, size=3, vjust = -1.5) + ggplot2::geom_hline(aes(yintercept = pers_avg), color = &quot;gray70&quot;, size = 0.6) + ggplot2::geom_text(aes(x = 0.7, y = pers_avg, label = paste(person,&quot; average age&quot;, round(pers_avg,0)), hjust = 1.05), colour = &quot;black&quot;, size = 3) + ggplot2::geom_segment(aes(x = prev_marriage, xend = prev_marriage, y = pers_avg, yend = pers_prev_avg), size = 0.8) + ggplot2::geom_dotplot(binaxis = &quot;y&quot;, dotsize = 1, method = &quot;dotdensity&quot;, binwidth = 0.5, alpha = 0.4, stackdir = &quot;center&quot;, stackratio = 1.5) + ggplot2::scale_color_brewer(type = &quot;qual&quot;, palette = &quot;Dark2&quot;) + ggplot2::scale_fill_brewer(type = &quot;qual&quot;, palette = &quot;Dark2&quot;) + ggplot2::theme_minimal() + ggplot2::theme( plot.title = element_text(size = 14, hjust = 0), legend.position = &quot;none&quot;, axis.title.x = element_blank(), axis.title.y = element_blank(), panel.grid = element_blank(), strip.text.x = element_text(size = 12, hjust = 0.1), panel.border = element_rect(colour = &quot;black&quot;, fill=NA, size = 0.1) ) + ggplot2::scale_y_continuous(breaks=base::seq(0,100,10)) + ggplot2::coord_flip() + ggplot2::labs( title = &quot;Age* of brides and grooms by previous marriage status&quot;, caption = &quot;*The average ages are the median, the middle age among all ages.\\n i.e. 50% of ages fall below the median value and 50% above it&quot; ) ggplot2::ggsave(file=&quot;marriage.svg&quot;, device = &quot;svg&quot;, plot=p) ## Saving 7 x 5 in image In the plot above we can see grooms are older on average overall. But do they tend to be older or younger than their bride within each marriage? As a final quick exploratory chart let’s put the ceremony ID on the x-axis, use ggplot2::geom_point() for age, and give the data points for brides and grooms their own colour. Adding the ceremony ID bookpageID to the group aesthetic means that when we add ggplot2::geom_line() this creates a line that joins the two data points for each marriage. We can see that most grooms are older than most brides in each ceremony. marriage %&gt;% ggplot2::ggplot() + ggplot2::aes(x = bookpageID, y = age, colour = person, group = bookpageID) + ggplot2::geom_point() + ggplot2::geom_line() + ggplot2::coord_flip() "],
["interactive-plots.html", "Chapter 6 Interactive plots 6.1 Plotly cheat: convert ggplot with plotly::ggplotly() 6.2 Edit ggplot conversion with plotly::plotly_build() 6.3 Plotly basic 6.4 plotly (a few more settings) 6.5 plotly (bells &amp; whistles) 6.6 crosstalk 6.7 apexcharter basic 6.8 apexcharter (bells &amp; whistles) 6.9 dygraphs basic 6.10 dygraphs (bells &amp; whistles)", " Chapter 6 Interactive plots 6.1 Plotly cheat: convert ggplot with plotly::ggplotly() Interactive plots can help both you and your audience find and tell stories in data faster and more enjoyably. Carson Sievert maintains the Plotly R package. He describes how interactive plots can “augment” your data exploration, but only if we can “iterate quickly”. With plotly you can sometimes move faster than ggplot with fewer errors. A quick way to use Plotly is to put a ggplot you have already built through a plotly function called plotly::ggplotly(), like this below. p &lt;- df_red %&gt;% ggplot2::ggplot() + ggplot2::aes(x = date, y = sales, colour = city) + ggplot2::geom_line() plotly::ggplotly(p) 6.2 Edit ggplot conversion with plotly::plotly_build() Often, even when you have played around with how the original ggplot looks, the plotly::ggplotly() function doesn’t quite convert to the plot you want. If that happens, try using plotly::plotly_build() instead of plotly::ggplotly(). It gives you more control over the conversion from ggplot to plotly. Plotly build is a nested R object which plotly.js uses to create the web graphic. This diagram from chapter 2 of Carson Sievert’s Interactive web-based data visualization with R, plotly, and shiny explains that relationship. plotly::plotly_build() contains all the settings used to create the plotly plot that we can now edit. p &lt;- df_red %&gt;% ggplot2::ggplot() + ggplot2::aes(x = date, y = sales, colour = city) + ggplot2::geom_line() p_build &lt;- plotly::plotly_build(p) p_build We can alter any of the settings in p_build we have created above. One way to find the value we want to edit is to use utils::str() to browse all of them in a large nested tree. str() compactly displays the structure of any R object. We run it on p_build below. Show full structure of p_build utils::str(p_build) ## List of 8 ## $ x :List of 10 ## ..$ data :List of 14 ## .. ..$ :List of 14 ## .. .. ..$ x : num [1:187] 10957 10988 11017 11048 11078 ... ## .. .. .. ..- attr(*, &quot;apiSrc&quot;)= logi TRUE ## .. .. ..$ y : num [1:187] 241 337 493 456 498 491 446 507 407 392 ... ## .. .. .. ..- attr(*, &quot;apiSrc&quot;)= logi TRUE ## .. .. ..$ text : chr [1:187] &quot;date: 2000-01-01&lt;br /&gt;sales: 241&lt;br /&gt;city: Arlington&quot; &quot;date: 2000-02-01&lt;br /&gt;sales: 337&lt;br /&gt;city: Arlington&quot; &quot;date: 2000-03-01&lt;br /&gt;sales: 493&lt;br /&gt;city: Arlington&quot; &quot;date: 2000-04-01&lt;br /&gt;sales: 456&lt;br /&gt;city: Arlington&quot; ... ## .. .. .. ..- attr(*, &quot;apiSrc&quot;)= logi TRUE ## .. .. ..$ type : chr &quot;scatter&quot; ## .. .. ..$ mode : chr &quot;lines&quot; ## .. .. ..$ line :List of 3 ## .. .. .. ..$ width: num 1.89 ## .. .. .. ..$ color: chr &quot;rgba(248,118,109,1)&quot; ## .. .. .. ..$ dash : chr &quot;solid&quot; ## .. .. ..$ hoveron : chr &quot;points&quot; ## .. .. ..$ name : chr &quot;Arlington&quot; ## .. .. ..$ legendgroup: chr &quot;Arlington&quot; ## .. .. ..$ showlegend : logi TRUE ## .. .. ..$ xaxis : chr &quot;x&quot; ## .. .. ..$ yaxis : chr &quot;y&quot; ## .. .. ..$ hoverinfo : chr &quot;text&quot; ## .. .. ..$ frame : chr NA ## .. ..$ :List of 14 ## .. .. ..$ x : num [1:187] 10957 10988 11017 11048 11078 ... ## .. .. .. ..- attr(*, &quot;apiSrc&quot;)= logi TRUE ## .. .. ..$ y : num [1:187] 1025 1277 1603 1556 1980 ... ## .. .. .. ..- attr(*, &quot;apiSrc&quot;)= logi TRUE ## .. .. ..$ text : chr [1:187] &quot;date: 2000-01-01&lt;br /&gt;sales: 1025&lt;br /&gt;city: Austin&quot; &quot;date: 2000-02-01&lt;br /&gt;sales: 1277&lt;br /&gt;city: Austin&quot; &quot;date: 2000-03-01&lt;br /&gt;sales: 1603&lt;br /&gt;city: Austin&quot; &quot;date: 2000-04-01&lt;br /&gt;sales: 1556&lt;br /&gt;city: Austin&quot; ... ## .. .. .. ..- attr(*, &quot;apiSrc&quot;)= logi TRUE ## .. .. ..$ type : chr &quot;scatter&quot; ## .. .. ..$ mode : chr &quot;lines&quot; ## .. .. ..$ line :List of 3 ## .. .. .. ..$ width: num 1.89 ## .. .. .. ..$ color: chr &quot;rgba(227,137,0,1)&quot; ## .. .. .. ..$ dash : chr &quot;solid&quot; ## .. .. ..$ hoveron : chr &quot;points&quot; ## .. .. ..$ name : chr &quot;Austin&quot; ## .. .. ..$ legendgroup: chr &quot;Austin&quot; ## .. .. ..$ showlegend : logi TRUE ## .. .. ..$ xaxis : chr &quot;x&quot; ## .. .. ..$ yaxis : chr &quot;y&quot; ## .. .. ..$ hoverinfo : chr &quot;text&quot; ## .. .. ..$ frame : chr NA ## .. ..$ :List of 14 ## .. .. ..$ x : num [1:187] 10957 10988 11017 11048 11078 ... ## .. .. .. ..- attr(*, &quot;apiSrc&quot;)= logi TRUE ## .. .. ..$ y : num [1:187] 244 375 391 421 533 561 449 471 397 376 ... ## .. .. .. ..- attr(*, &quot;apiSrc&quot;)= logi TRUE ## .. .. ..$ text : chr [1:187] &quot;date: 2000-01-01&lt;br /&gt;sales: 244&lt;br /&gt;city: Bay Area&quot; &quot;date: 2000-02-01&lt;br /&gt;sales: 375&lt;br /&gt;city: Bay Area&quot; &quot;date: 2000-03-01&lt;br /&gt;sales: 391&lt;br /&gt;city: Bay Area&quot; &quot;date: 2000-04-01&lt;br /&gt;sales: 421&lt;br /&gt;city: Bay Area&quot; ... ## .. .. .. ..- attr(*, &quot;apiSrc&quot;)= logi TRUE ## .. .. ..$ type : chr &quot;scatter&quot; ## .. .. ..$ mode : chr &quot;lines&quot; ## .. .. ..$ line :List of 3 ## .. .. .. ..$ width: num 1.89 ## .. .. .. ..$ color: chr &quot;rgba(196,154,0,1)&quot; ## .. .. .. ..$ dash : chr &quot;solid&quot; ## .. .. ..$ hoveron : chr &quot;points&quot; ## .. .. ..$ name : chr &quot;Bay Area&quot; ## .. .. ..$ legendgroup: chr &quot;Bay Area&quot; ## .. .. ..$ showlegend : logi TRUE ## .. .. ..$ xaxis : chr &quot;x&quot; ## .. .. ..$ yaxis : chr &quot;y&quot; ## .. .. ..$ hoverinfo : chr &quot;text&quot; ## .. .. ..$ frame : chr NA ## .. ..$ :List of 14 ## .. .. ..$ x : num [1:187] 10957 10988 11017 11048 11078 ... ## .. .. .. ..- attr(*, &quot;apiSrc&quot;)= logi TRUE ## .. .. ..$ y : num [1:187] 464 668 849 847 1031 ... ## .. .. .. ..- attr(*, &quot;apiSrc&quot;)= logi TRUE ## .. .. ..$ text : chr [1:187] &quot;date: 2000-01-01&lt;br /&gt;sales: 464&lt;br /&gt;city: Collin County&quot; &quot;date: 2000-02-01&lt;br /&gt;sales: 668&lt;br /&gt;city: Collin County&quot; &quot;date: 2000-03-01&lt;br /&gt;sales: 849&lt;br /&gt;city: Collin County&quot; &quot;date: 2000-04-01&lt;br /&gt;sales: 847&lt;br /&gt;city: Collin County&quot; ... ## .. .. .. ..- attr(*, &quot;apiSrc&quot;)= logi TRUE ## .. .. ..$ type : chr &quot;scatter&quot; ## .. .. ..$ mode : chr &quot;lines&quot; ## .. .. ..$ line :List of 3 ## .. .. .. ..$ width: num 1.89 ## .. .. .. ..$ color: chr &quot;rgba(153,168,0,1)&quot; ## .. .. .. ..$ dash : chr &quot;solid&quot; ## .. .. ..$ hoveron : chr &quot;points&quot; ## .. .. ..$ name : chr &quot;Collin County&quot; ## .. .. ..$ legendgroup: chr &quot;Collin County&quot; ## .. .. ..$ showlegend : logi TRUE ## .. .. ..$ xaxis : chr &quot;x&quot; ## .. .. ..$ yaxis : chr &quot;y&quot; ## .. .. ..$ hoverinfo : chr &quot;text&quot; ## .. .. ..$ frame : chr NA ## .. ..$ :List of 14 ## .. .. ..$ x : num [1:187] 10957 10988 11017 11048 11078 ... ## .. .. .. ..- attr(*, &quot;apiSrc&quot;)= logi TRUE ## .. .. ..$ y : num [1:187] 182 219 351 288 317 339 287 398 307 274 ... ## .. .. .. ..- attr(*, &quot;apiSrc&quot;)= logi TRUE ## .. .. ..$ text : chr [1:187] &quot;date: 2000-01-01&lt;br /&gt;sales: 182&lt;br /&gt;city: Corpus Christi&quot; &quot;date: 2000-02-01&lt;br /&gt;sales: 219&lt;br /&gt;city: Corpus Christi&quot; &quot;date: 2000-03-01&lt;br /&gt;sales: 351&lt;br /&gt;city: Corpus Christi&quot; &quot;date: 2000-04-01&lt;br /&gt;sales: 288&lt;br /&gt;city: Corpus Christi&quot; ... ## .. .. .. ..- attr(*, &quot;apiSrc&quot;)= logi TRUE ## .. .. ..$ type : chr &quot;scatter&quot; ## .. .. ..$ mode : chr &quot;lines&quot; ## .. .. ..$ line :List of 3 ## .. .. .. ..$ width: num 1.89 ## .. .. .. ..$ color: chr &quot;rgba(83,180,0,1)&quot; ## .. .. .. ..$ dash : chr &quot;solid&quot; ## .. .. ..$ hoveron : chr &quot;points&quot; ## .. .. ..$ name : chr &quot;Corpus Christi&quot; ## .. .. ..$ legendgroup: chr &quot;Corpus Christi&quot; ## .. .. ..$ showlegend : logi TRUE ## .. .. ..$ xaxis : chr &quot;x&quot; ## .. .. ..$ yaxis : chr &quot;y&quot; ## .. .. ..$ hoverinfo : chr &quot;text&quot; ## .. .. ..$ frame : chr NA ## .. ..$ :List of 14 ## .. .. ..$ x : num [1:187] 10957 10988 11017 11048 11078 ... ## .. .. .. ..- attr(*, &quot;apiSrc&quot;)= logi TRUE ## .. .. ..$ y : num [1:187] 2286 3247 4244 3977 4545 ... ## .. .. .. ..- attr(*, &quot;apiSrc&quot;)= logi TRUE ## .. .. ..$ text : chr [1:187] &quot;date: 2000-01-01&lt;br /&gt;sales: 2286&lt;br /&gt;city: Dallas&quot; &quot;date: 2000-02-01&lt;br /&gt;sales: 3247&lt;br /&gt;city: Dallas&quot; &quot;date: 2000-03-01&lt;br /&gt;sales: 4244&lt;br /&gt;city: Dallas&quot; &quot;date: 2000-04-01&lt;br /&gt;sales: 3977&lt;br /&gt;city: Dallas&quot; ... ## .. .. .. ..- attr(*, &quot;apiSrc&quot;)= logi TRUE ## .. .. ..$ type : chr &quot;scatter&quot; ## .. .. ..$ mode : chr &quot;lines&quot; ## .. .. ..$ line :List of 3 ## .. .. .. ..$ width: num 1.89 ## .. .. .. ..$ color: chr &quot;rgba(0,188,86,1)&quot; ## .. .. .. ..$ dash : chr &quot;solid&quot; ## .. .. ..$ hoveron : chr &quot;points&quot; ## .. .. ..$ name : chr &quot;Dallas&quot; ## .. .. ..$ legendgroup: chr &quot;Dallas&quot; ## .. .. ..$ showlegend : logi TRUE ## .. .. ..$ xaxis : chr &quot;x&quot; ## .. .. ..$ yaxis : chr &quot;y&quot; ## .. .. ..$ hoverinfo : chr &quot;text&quot; ## .. .. ..$ frame : chr NA ## .. ..$ :List of 14 ## .. .. ..$ x : num [1:187] 10957 10988 11017 11048 11078 ... ## .. .. .. ..- attr(*, &quot;apiSrc&quot;)= logi TRUE ## .. .. ..$ y : num [1:187] 313 423 570 529 639 677 638 618 488 460 ... ## .. .. .. ..- attr(*, &quot;apiSrc&quot;)= logi TRUE ## .. .. ..$ text : chr [1:187] &quot;date: 2000-01-01&lt;br /&gt;sales: 313&lt;br /&gt;city: Denton County&quot; &quot;date: 2000-02-01&lt;br /&gt;sales: 423&lt;br /&gt;city: Denton County&quot; &quot;date: 2000-03-01&lt;br /&gt;sales: 570&lt;br /&gt;city: Denton County&quot; &quot;date: 2000-04-01&lt;br /&gt;sales: 529&lt;br /&gt;city: Denton County&quot; ... ## .. .. .. ..- attr(*, &quot;apiSrc&quot;)= logi TRUE ## .. .. ..$ type : chr &quot;scatter&quot; ## .. .. ..$ mode : chr &quot;lines&quot; ## .. .. ..$ line :List of 3 ## .. .. .. ..$ width: num 1.89 ## .. .. .. ..$ color: chr &quot;rgba(0,192,148,1)&quot; ## .. .. .. ..$ dash : chr &quot;solid&quot; ## .. .. ..$ hoveron : chr &quot;points&quot; ## .. .. ..$ name : chr &quot;Denton County&quot; ## .. .. ..$ legendgroup: chr &quot;Denton County&quot; ## .. .. ..$ showlegend : logi TRUE ## .. .. ..$ xaxis : chr &quot;x&quot; ## .. .. ..$ yaxis : chr &quot;y&quot; ## .. .. ..$ hoverinfo : chr &quot;text&quot; ## .. .. ..$ frame : chr NA ## .. ..$ :List of 14 ## .. .. ..$ x : num [1:187] 10957 10988 11017 11048 11078 ... ## .. .. .. ..- attr(*, &quot;apiSrc&quot;)= logi TRUE ## .. .. ..$ y : num [1:187] 306 346 492 382 459 486 422 538 382 392 ... ## .. .. .. ..- attr(*, &quot;apiSrc&quot;)= logi TRUE ## .. .. ..$ text : chr [1:187] &quot;date: 2000-01-01&lt;br /&gt;sales: 306&lt;br /&gt;city: El Paso&quot; &quot;date: 2000-02-01&lt;br /&gt;sales: 346&lt;br /&gt;city: El Paso&quot; &quot;date: 2000-03-01&lt;br /&gt;sales: 492&lt;br /&gt;city: El Paso&quot; &quot;date: 2000-04-01&lt;br /&gt;sales: 382&lt;br /&gt;city: El Paso&quot; ... ## .. .. .. ..- attr(*, &quot;apiSrc&quot;)= logi TRUE ## .. .. ..$ type : chr &quot;scatter&quot; ## .. .. ..$ mode : chr &quot;lines&quot; ## .. .. ..$ line :List of 3 ## .. .. .. ..$ width: num 1.89 ## .. .. .. ..$ color: chr &quot;rgba(0,191,196,1)&quot; ## .. .. .. ..$ dash : chr &quot;solid&quot; ## .. .. ..$ hoveron : chr &quot;points&quot; ## .. .. ..$ name : chr &quot;El Paso&quot; ## .. .. ..$ legendgroup: chr &quot;El Paso&quot; ## .. .. ..$ showlegend : logi TRUE ## .. .. ..$ xaxis : chr &quot;x&quot; ## .. .. ..$ yaxis : chr &quot;y&quot; ## .. .. ..$ hoverinfo : chr &quot;text&quot; ## .. .. ..$ frame : chr NA ## .. ..$ :List of 14 ## .. .. ..$ x : num [1:187] 10957 10988 11017 11048 11078 ... ## .. .. .. ..- attr(*, &quot;apiSrc&quot;)= logi TRUE ## .. .. ..$ y : num [1:187] 343 466 657 593 735 790 753 717 593 547 ... ## .. .. .. ..- attr(*, &quot;apiSrc&quot;)= logi TRUE ## .. .. ..$ text : chr [1:187] &quot;date: 2000-01-01&lt;br /&gt;sales: 343&lt;br /&gt;city: Fort Bend&quot; &quot;date: 2000-02-01&lt;br /&gt;sales: 466&lt;br /&gt;city: Fort Bend&quot; &quot;date: 2000-03-01&lt;br /&gt;sales: 657&lt;br /&gt;city: Fort Bend&quot; &quot;date: 2000-04-01&lt;br /&gt;sales: 593&lt;br /&gt;city: Fort Bend&quot; ... ## .. .. .. ..- attr(*, &quot;apiSrc&quot;)= logi TRUE ## .. .. ..$ type : chr &quot;scatter&quot; ## .. .. ..$ mode : chr &quot;lines&quot; ## .. .. ..$ line :List of 3 ## .. .. .. ..$ width: num 1.89 ## .. .. .. ..$ color: chr &quot;rgba(0,182,235,1)&quot; ## .. .. .. ..$ dash : chr &quot;solid&quot; ## .. .. ..$ hoveron : chr &quot;points&quot; ## .. .. ..$ name : chr &quot;Fort Bend&quot; ## .. .. ..$ legendgroup: chr &quot;Fort Bend&quot; ## .. .. ..$ showlegend : logi TRUE ## .. .. ..$ xaxis : chr &quot;x&quot; ## .. .. ..$ yaxis : chr &quot;y&quot; ## .. .. ..$ hoverinfo : chr &quot;text&quot; ## .. .. ..$ frame : chr NA ## .. ..$ :List of 14 ## .. .. ..$ x : num [1:187] 10957 10988 11017 11048 11078 ... ## .. .. .. ..- attr(*, &quot;apiSrc&quot;)= logi TRUE ## .. .. ..$ y : num [1:187] 325 469 588 487 630 648 548 638 524 539 ... ## .. .. .. ..- attr(*, &quot;apiSrc&quot;)= logi TRUE ## .. .. ..$ text : chr [1:187] &quot;date: 2000-01-01&lt;br /&gt;sales: 325&lt;br /&gt;city: Fort Worth&quot; &quot;date: 2000-02-01&lt;br /&gt;sales: 469&lt;br /&gt;city: Fort Worth&quot; &quot;date: 2000-03-01&lt;br /&gt;sales: 588&lt;br /&gt;city: Fort Worth&quot; &quot;date: 2000-04-01&lt;br /&gt;sales: 487&lt;br /&gt;city: Fort Worth&quot; ... ## .. .. .. ..- attr(*, &quot;apiSrc&quot;)= logi TRUE ## .. .. ..$ type : chr &quot;scatter&quot; ## .. .. ..$ mode : chr &quot;lines&quot; ## .. .. ..$ line :List of 3 ## .. .. .. ..$ width: num 1.89 ## .. .. .. ..$ color: chr &quot;rgba(6,164,255,1)&quot; ## .. .. .. ..$ dash : chr &quot;solid&quot; ## .. .. ..$ hoveron : chr &quot;points&quot; ## .. .. ..$ name : chr &quot;Fort Worth&quot; ## .. .. ..$ legendgroup: chr &quot;Fort Worth&quot; ## .. .. ..$ showlegend : logi TRUE ## .. .. ..$ xaxis : chr &quot;x&quot; ## .. .. ..$ yaxis : chr &quot;y&quot; ## .. .. ..$ hoverinfo : chr &quot;text&quot; ## .. .. ..$ frame : chr NA ## .. ..$ :List of 14 ## .. .. ..$ x : num [1:187] 10957 10988 11017 11048 11078 ... ## .. .. .. ..- attr(*, &quot;apiSrc&quot;)= logi TRUE ## .. .. ..$ y : num [1:187] 2653 3687 4733 4364 5215 ... ## .. .. .. ..- attr(*, &quot;apiSrc&quot;)= logi TRUE ## .. .. ..$ text : chr [1:187] &quot;date: 2000-01-01&lt;br /&gt;sales: 2653&lt;br /&gt;city: Houston&quot; &quot;date: 2000-02-01&lt;br /&gt;sales: 3687&lt;br /&gt;city: Houston&quot; &quot;date: 2000-03-01&lt;br /&gt;sales: 4733&lt;br /&gt;city: Houston&quot; &quot;date: 2000-04-01&lt;br /&gt;sales: 4364&lt;br /&gt;city: Houston&quot; ... ## .. .. .. ..- attr(*, &quot;apiSrc&quot;)= logi TRUE ## .. .. ..$ type : chr &quot;scatter&quot; ## .. .. ..$ mode : chr &quot;lines&quot; ## .. .. ..$ line :List of 3 ## .. .. .. ..$ width: num 1.89 ## .. .. .. ..$ color: chr &quot;rgba(165,138,255,1)&quot; ## .. .. .. ..$ dash : chr &quot;solid&quot; ## .. .. ..$ hoveron : chr &quot;points&quot; ## .. .. ..$ name : chr &quot;Houston&quot; ## .. .. ..$ legendgroup: chr &quot;Houston&quot; ## .. .. ..$ showlegend : logi TRUE ## .. .. ..$ xaxis : chr &quot;x&quot; ## .. .. ..$ yaxis : chr &quot;y&quot; ## .. .. ..$ hoverinfo : chr &quot;text&quot; ## .. .. ..$ frame : chr NA ## .. ..$ :List of 14 ## .. .. ..$ x : num [1:187] 10957 10988 11017 11048 11078 ... ## .. .. .. ..- attr(*, &quot;apiSrc&quot;)= logi TRUE ## .. .. ..$ y : num [1:187] 259 309 420 383 427 492 463 460 346 321 ... ## .. .. .. ..- attr(*, &quot;apiSrc&quot;)= logi TRUE ## .. .. ..$ text : chr [1:187] &quot;date: 2000-01-01&lt;br /&gt;sales: 259&lt;br /&gt;city: Montgomery County&quot; &quot;date: 2000-02-01&lt;br /&gt;sales: 309&lt;br /&gt;city: Montgomery County&quot; &quot;date: 2000-03-01&lt;br /&gt;sales: 420&lt;br /&gt;city: Montgomery County&quot; &quot;date: 2000-04-01&lt;br /&gt;sales: 383&lt;br /&gt;city: Montgomery County&quot; ... ## .. .. .. ..- attr(*, &quot;apiSrc&quot;)= logi TRUE ## .. .. ..$ type : chr &quot;scatter&quot; ## .. .. ..$ mode : chr &quot;lines&quot; ## .. .. ..$ line :List of 3 ## .. .. .. ..$ width: num 1.89 ## .. .. .. ..$ color: chr &quot;rgba(223,112,248,1)&quot; ## .. .. .. ..$ dash : chr &quot;solid&quot; ## .. .. ..$ hoveron : chr &quot;points&quot; ## .. .. ..$ name : chr &quot;Montgomery County&quot; ## .. .. ..$ legendgroup: chr &quot;Montgomery County&quot; ## .. .. ..$ showlegend : logi TRUE ## .. .. ..$ xaxis : chr &quot;x&quot; ## .. .. ..$ yaxis : chr &quot;y&quot; ## .. .. ..$ hoverinfo : chr &quot;text&quot; ## .. .. ..$ frame : chr NA ## .. ..$ :List of 14 ## .. .. ..$ x : num [1:187] 10957 10988 11017 11048 11078 ... ## .. .. .. ..- attr(*, &quot;apiSrc&quot;)= logi TRUE ## .. .. ..$ y : num [1:187] 344 531 717 590 746 727 686 717 551 556 ... ## .. .. .. ..- attr(*, &quot;apiSrc&quot;)= logi TRUE ## .. .. ..$ text : chr [1:187] &quot;date: 2000-01-01&lt;br /&gt;sales: 344&lt;br /&gt;city: NE Tarrant County&quot; &quot;date: 2000-02-01&lt;br /&gt;sales: 531&lt;br /&gt;city: NE Tarrant County&quot; &quot;date: 2000-03-01&lt;br /&gt;sales: 717&lt;br /&gt;city: NE Tarrant County&quot; &quot;date: 2000-04-01&lt;br /&gt;sales: 590&lt;br /&gt;city: NE Tarrant County&quot; ... ## .. .. .. ..- attr(*, &quot;apiSrc&quot;)= logi TRUE ## .. .. ..$ type : chr &quot;scatter&quot; ## .. .. ..$ mode : chr &quot;lines&quot; ## .. .. ..$ line :List of 3 ## .. .. .. ..$ width: num 1.89 ## .. .. .. ..$ color: chr &quot;rgba(251,97,215,1)&quot; ## .. .. .. ..$ dash : chr &quot;solid&quot; ## .. .. ..$ hoveron : chr &quot;points&quot; ## .. .. ..$ name : chr &quot;NE Tarrant County&quot; ## .. .. ..$ legendgroup: chr &quot;NE Tarrant County&quot; ## .. .. ..$ showlegend : logi TRUE ## .. .. ..$ xaxis : chr &quot;x&quot; ## .. .. ..$ yaxis : chr &quot;y&quot; ## .. .. ..$ hoverinfo : chr &quot;text&quot; ## .. .. ..$ frame : chr NA ## .. ..$ :List of 14 ## .. .. ..$ x : num [1:187] 10957 10988 11017 11048 11078 ... ## .. .. .. ..- attr(*, &quot;apiSrc&quot;)= logi TRUE ## .. .. ..$ y : num [1:187] 820 1075 1433 1263 1574 ... ## .. .. .. ..- attr(*, &quot;apiSrc&quot;)= logi TRUE ## .. .. ..$ text : chr [1:187] &quot;date: 2000-01-01&lt;br /&gt;sales: 820&lt;br /&gt;city: San Antonio&quot; &quot;date: 2000-02-01&lt;br /&gt;sales: 1075&lt;br /&gt;city: San Antonio&quot; &quot;date: 2000-03-01&lt;br /&gt;sales: 1433&lt;br /&gt;city: San Antonio&quot; &quot;date: 2000-04-01&lt;br /&gt;sales: 1263&lt;br /&gt;city: San Antonio&quot; ... ## .. .. .. ..- attr(*, &quot;apiSrc&quot;)= logi TRUE ## .. .. ..$ type : chr &quot;scatter&quot; ## .. .. ..$ mode : chr &quot;lines&quot; ## .. .. ..$ line :List of 3 ## .. .. .. ..$ width: num 1.89 ## .. .. .. ..$ color: chr &quot;rgba(255,102,168,1)&quot; ## .. .. .. ..$ dash : chr &quot;solid&quot; ## .. .. ..$ hoveron : chr &quot;points&quot; ## .. .. ..$ name : chr &quot;San Antonio&quot; ## .. .. ..$ legendgroup: chr &quot;San Antonio&quot; ## .. .. ..$ showlegend : logi TRUE ## .. .. ..$ xaxis : chr &quot;x&quot; ## .. .. ..$ yaxis : chr &quot;y&quot; ## .. .. ..$ hoverinfo : chr &quot;text&quot; ## .. .. ..$ frame : chr NA ## ..$ layout :List of 10 ## .. ..$ margin :List of 4 ## .. .. ..$ t: num 26.2 ## .. .. ..$ r: num 7.31 ## .. .. ..$ b: num 40.4 ## .. .. ..$ l: num 48.9 ## .. ..$ font :List of 3 ## .. .. ..$ color : chr &quot;rgba(0,0,0,1)&quot; ## .. .. ..$ family: chr &quot;&quot; ## .. .. ..$ size : num 14.6 ## .. ..$ xaxis :List of 28 ## .. .. ..$ domain : num [1:2] 0 1 ## .. .. ..$ automargin : logi TRUE ## .. .. ..$ type : chr &quot;linear&quot; ## .. .. ..$ autorange : logi FALSE ## .. .. ..$ range : num [1:2] 10674 16900 ## .. .. ..$ tickmode : chr &quot;array&quot; ## .. .. ..$ ticktext : chr [1:4] &quot;2000&quot; &quot;2005&quot; &quot;2010&quot; &quot;2015&quot; ## .. .. ..$ tickvals : Named num [1:4] 10957 12784 14610 16436 ## .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:4] &quot;2000&quot; &quot;2005&quot; &quot;2010&quot; &quot;2015&quot; ## .. .. ..$ categoryorder : chr &quot;array&quot; ## .. .. ..$ categoryarray : chr [1:4] &quot;2000&quot; &quot;2005&quot; &quot;2010&quot; &quot;2015&quot; ## .. .. ..$ nticks : logi NA ## .. .. ..$ ticks : chr &quot;&quot; ## .. .. ..$ tickcolor : logi NA ## .. .. ..$ ticklen : num 3.65 ## .. .. ..$ tickwidth : num 0 ## .. .. ..$ showticklabels: logi TRUE ## .. .. ..$ tickfont :List of 3 ## .. .. .. ..$ color : chr &quot;rgba(77,77,77,1)&quot; ## .. .. .. ..$ family: chr &quot;&quot; ## .. .. .. ..$ size : num 12 ## .. .. ..$ tickangle : num -60 ## .. .. ..$ showline : logi FALSE ## .. .. ..$ linecolor : logi NA ## .. .. ..$ linewidth : num 0 ## .. .. ..$ showgrid : logi FALSE ## .. .. ..$ gridcolor : logi NA ## .. .. ..$ gridwidth : num 0 ## .. .. ..$ zeroline : logi FALSE ## .. .. ..$ anchor : chr &quot;y&quot; ## .. .. ..$ title :List of 2 ## .. .. .. ..$ text: chr &quot;date&quot; ## .. .. .. ..$ font:List of 3 ## .. .. .. .. ..$ color : chr &quot;rgba(0,0,0,1)&quot; ## .. .. .. .. ..$ family: chr &quot;&quot; ## .. .. .. .. ..$ size : num 14.6 ## .. .. ..$ hoverformat : chr &quot;.2f&quot; ## .. ..$ yaxis :List of 28 ## .. .. ..$ domain : num [1:2] 0 1 ## .. .. ..$ automargin : logi TRUE ## .. .. ..$ type : chr &quot;linear&quot; ## .. .. ..$ autorange : logi FALSE ## .. .. ..$ range : num [1:2] -281 9384 ## .. .. ..$ tickmode : chr &quot;array&quot; ## .. .. ..$ ticktext : chr [1:4] &quot;0&quot; &quot;2500&quot; &quot;5000&quot; &quot;7500&quot; ## .. .. ..$ tickvals : num [1:4] 0 2500 5000 7500 ## .. .. ..$ categoryorder : chr &quot;array&quot; ## .. .. ..$ categoryarray : chr [1:4] &quot;0&quot; &quot;2500&quot; &quot;5000&quot; &quot;7500&quot; ## .. .. ..$ nticks : logi NA ## .. .. ..$ ticks : chr &quot;&quot; ## .. .. ..$ tickcolor : logi NA ## .. .. ..$ ticklen : num 3.65 ## .. .. ..$ tickwidth : num 0 ## .. .. ..$ showticklabels: logi TRUE ## .. .. ..$ tickfont :List of 3 ## .. .. .. ..$ color : chr &quot;rgba(77,77,77,1)&quot; ## .. .. .. ..$ family: chr &quot;&quot; ## .. .. .. ..$ size : num 11.7 ## .. .. ..$ tickangle : num 0 ## .. .. ..$ showline : logi FALSE ## .. .. ..$ linecolor : logi NA ## .. .. ..$ linewidth : num 0 ## .. .. ..$ showgrid : logi TRUE ## .. .. ..$ gridcolor : chr &quot;rgba(235,235,235,1)&quot; ## .. .. ..$ gridwidth : num 0.664 ## .. .. ..$ zeroline : logi FALSE ## .. .. ..$ anchor : chr &quot;x&quot; ## .. .. ..$ title :List of 2 ## .. .. .. ..$ text: chr &quot;sales&quot; ## .. .. .. ..$ font:List of 3 ## .. .. .. .. ..$ color : chr &quot;rgba(0,0,0,1)&quot; ## .. .. .. .. ..$ family: chr &quot;&quot; ## .. .. .. .. ..$ size : num 14.6 ## .. .. ..$ hoverformat : chr &quot;.2f&quot; ## .. ..$ shapes :List of 1 ## .. .. ..$ :List of 9 ## .. .. .. ..$ type : chr &quot;rect&quot; ## .. .. .. ..$ fillcolor: logi NA ## .. .. .. ..$ line :List of 3 ## .. .. .. .. ..$ color : logi NA ## .. .. .. .. ..$ width : num 0 ## .. .. .. .. ..$ linetype: chr(0) ## .. .. .. ..$ yref : chr &quot;paper&quot; ## .. .. .. ..$ xref : chr &quot;paper&quot; ## .. .. .. ..$ x0 : num 0 ## .. .. .. ..$ x1 : num 1 ## .. .. .. ..$ y0 : num 0 ## .. .. .. ..$ y1 : num 1 ## .. ..$ showlegend : logi TRUE ## .. ..$ legend :List of 5 ## .. .. ..$ bgcolor : logi NA ## .. .. ..$ bordercolor: logi NA ## .. .. ..$ borderwidth: num 0 ## .. .. ..$ font :List of 3 ## .. .. .. ..$ color : chr &quot;rgba(0,0,0,1)&quot; ## .. .. .. ..$ family: chr &quot;&quot; ## .. .. .. ..$ size : num 11.7 ## .. .. ..$ y : num 0.968 ## .. ..$ annotations:List of 1 ## .. .. ..$ :List of 13 ## .. .. .. ..$ text : chr &quot;city&quot; ## .. .. .. ..$ x : num 1.02 ## .. .. .. ..$ y : num 1 ## .. .. .. ..$ showarrow : logi FALSE ## .. .. .. ..$ ax : num 0 ## .. .. .. ..$ ay : num 0 ## .. .. .. ..$ font :List of 3 ## .. .. .. .. ..$ color : chr &quot;rgba(0,0,0,1)&quot; ## .. .. .. .. ..$ family: chr &quot;&quot; ## .. .. .. .. ..$ size : num 14.6 ## .. .. .. ..$ xref : chr &quot;paper&quot; ## .. .. .. ..$ yref : chr &quot;paper&quot; ## .. .. .. ..$ textangle : num 0 ## .. .. .. ..$ xanchor : chr &quot;left&quot; ## .. .. .. ..$ yanchor : chr &quot;bottom&quot; ## .. .. .. ..$ legendTitle: logi TRUE ## .. ..$ hovermode : chr &quot;closest&quot; ## .. ..$ barmode : chr &quot;relative&quot; ## ..$ config :List of 2 ## .. ..$ doubleClick : chr &quot;reset&quot; ## .. ..$ showSendToCloud: logi FALSE ## ..$ source : chr &quot;A&quot; ## ..$ attrs :List of 1 ## .. ..$ 4ac434442cfd:List of 4 ## .. .. ..$ x :Class &#39;formula&#39; language ~~date ## .. .. .. .. ..- attr(*, &quot;.Environment&quot;)=&lt;environment: 0x00000000236c34f8&gt; ## .. .. ..$ y :Class &#39;formula&#39; language ~~sales ## .. .. .. .. ..- attr(*, &quot;.Environment&quot;)=&lt;environment: 0x00000000236c34f8&gt; ## .. .. ..$ colour:Class &#39;formula&#39; language ~~city ## .. .. .. .. ..- attr(*, &quot;.Environment&quot;)=&lt;environment: 0x00000000236c34f8&gt; ## .. .. ..$ type : chr &quot;scatter&quot; ## .. .. ..- attr(*, &quot;class&quot;)= chr &quot;plotly_eval&quot; ## ..$ cur_data : chr &quot;4ac434442cfd&quot; ## ..$ visdat :List of 1 ## .. ..$ 4ac434442cfd:function (y) ## ..$ highlight :List of 7 ## .. ..$ on : chr &quot;plotly_click&quot; ## .. ..$ persistent: logi FALSE ## .. ..$ dynamic : logi FALSE ## .. ..$ selectize : logi FALSE ## .. ..$ opacityDim: num 0.2 ## .. ..$ selected :List of 1 ## .. .. ..$ opacity: num 1 ## .. ..$ debounce : num 0 ## ..$ shinyEvents: chr [1:11] &quot;plotly_hover&quot; &quot;plotly_click&quot; &quot;plotly_selected&quot; &quot;plotly_relayout&quot; ... ## ..$ base_url : chr &quot;https://plot.ly&quot; ## ..- attr(*, &quot;TOJSON_FUNC&quot;)=function (x, ...) ## $ width : NULL ## $ height : NULL ## $ sizingPolicy :List of 6 ## ..$ defaultWidth : chr &quot;100%&quot; ## ..$ defaultHeight: num 400 ## ..$ padding : NULL ## ..$ viewer :List of 6 ## .. ..$ defaultWidth : NULL ## .. ..$ defaultHeight: NULL ## .. ..$ padding : NULL ## .. ..$ fill : logi TRUE ## .. ..$ suppress : logi FALSE ## .. ..$ paneHeight : NULL ## ..$ browser :List of 5 ## .. ..$ defaultWidth : NULL ## .. ..$ defaultHeight: NULL ## .. ..$ padding : NULL ## .. ..$ fill : logi TRUE ## .. ..$ external : logi FALSE ## ..$ knitr :List of 3 ## .. ..$ defaultWidth : NULL ## .. ..$ defaultHeight: NULL ## .. ..$ figure : logi TRUE ## $ dependencies :List of 5 ## ..$ :List of 10 ## .. ..$ name : chr &quot;typedarray&quot; ## .. ..$ version : chr &quot;0.1&quot; ## .. ..$ src :List of 1 ## .. .. ..$ file: chr &quot;htmlwidgets/lib/typedarray&quot; ## .. ..$ meta : NULL ## .. ..$ script : chr &quot;typedarray.min.js&quot; ## .. ..$ stylesheet: NULL ## .. ..$ head : NULL ## .. ..$ attachment: NULL ## .. ..$ package : chr &quot;plotly&quot; ## .. ..$ all_files : logi FALSE ## .. ..- attr(*, &quot;class&quot;)= chr &quot;html_dependency&quot; ## ..$ :List of 10 ## .. ..$ name : chr &quot;jquery&quot; ## .. ..$ version : chr &quot;1.11.3&quot; ## .. ..$ src :List of 1 ## .. .. ..$ file: chr &quot;C:/Users/lexybill/OneDrive/Documents/R/win-library/3.6/crosstalk/lib/jquery&quot; ## .. ..$ meta : NULL ## .. ..$ script : chr &quot;jquery.min.js&quot; ## .. ..$ stylesheet: NULL ## .. ..$ head : NULL ## .. ..$ attachment: NULL ## .. ..$ package : NULL ## .. ..$ all_files : logi TRUE ## .. ..- attr(*, &quot;class&quot;)= chr &quot;html_dependency&quot; ## ..$ :List of 10 ## .. ..$ name : chr &quot;crosstalk&quot; ## .. ..$ version : chr &quot;1.0.0&quot; ## .. ..$ src :List of 1 ## .. .. ..$ file: chr &quot;C:/Users/lexybill/OneDrive/Documents/R/win-library/3.6/crosstalk/www&quot; ## .. ..$ meta : NULL ## .. ..$ script : chr &quot;js/crosstalk.min.js&quot; ## .. ..$ stylesheet: chr &quot;css/crosstalk.css&quot; ## .. ..$ head : NULL ## .. ..$ attachment: NULL ## .. ..$ package : NULL ## .. ..$ all_files : logi TRUE ## .. ..- attr(*, &quot;class&quot;)= chr &quot;html_dependency&quot; ## ..$ :List of 10 ## .. ..$ name : chr &quot;plotly-htmlwidgets-css&quot; ## .. ..$ version : chr &quot;1.49.4&quot; ## .. ..$ src :List of 1 ## .. .. ..$ file: chr &quot;htmlwidgets/lib/plotlyjs&quot; ## .. ..$ meta : NULL ## .. ..$ script : NULL ## .. ..$ stylesheet: chr &quot;plotly-htmlwidgets.css&quot; ## .. ..$ head : NULL ## .. ..$ attachment: NULL ## .. ..$ package : chr &quot;plotly&quot; ## .. ..$ all_files : logi FALSE ## .. ..- attr(*, &quot;class&quot;)= chr &quot;html_dependency&quot; ## ..$ :List of 10 ## .. ..$ name : chr &quot;plotly-main&quot; ## .. ..$ version : chr &quot;1.49.4&quot; ## .. ..$ src :List of 1 ## .. .. ..$ file: chr &quot;htmlwidgets/lib/plotlyjs&quot; ## .. ..$ meta : NULL ## .. ..$ script : chr &quot;plotly-latest.min.js&quot; ## .. ..$ stylesheet: NULL ## .. ..$ head : NULL ## .. ..$ attachment: NULL ## .. ..$ package : chr &quot;plotly&quot; ## .. ..$ all_files : logi FALSE ## .. ..- attr(*, &quot;class&quot;)= chr &quot;html_dependency&quot; ## $ elementId : NULL ## $ preRenderHook:function (p, registerFrames = TRUE) ## $ jsHooks : list() ## - attr(*, &quot;class&quot;)= chr [1:2] &quot;plotly&quot; &quot;htmlwidget&quot; ## - attr(*, &quot;package&quot;)= chr &quot;plotly&quot; In the code below we set the font size of the x-axis to 42. We found this font setting by browsing the object structure of p_build with utils::str() in the tree shown above. Then, to create the code that alters the value we have found with str(), put a $ at the end of p_build in the console and hit the tab key. It shows all the named elements of the first nested level. We can then work our way down the nested levels by adding dollar signs to the next level and hitting tab. Repeat this until you have worked your way to the bottom of the tree and found the setting you want to change. p_build$x$layout$xaxis$tickfont$size = 42 p_build The code above has changed the font size to a massive 42 in the chart above. However, this dollar and tab key method to search through the named elements of the nested plotly object is fiddly and time-consuming. The gif below shows an easier Point and Click method. This feature is only available in RStudio versions from 1.1.383 onwards. To do this, in the Environment pane click on the magnifying glass to the right of p_build. You can then expand the nested lists as a tree. Browse the tree to find the value you want to change. To the right of each value at the bottom of the tree is an icon. Clicking on the icon will automatically generate the code you need to alter that value. Below is example code generated by this PaC method. p_build[[\"x\"]][[\"layout\"]][[\"xaxis\"]][[\"tickfont\"]][[\"size\"]] And here is how we alter that code to change the font size to 42 as we did with the dollar and tab method previously. p_build[[\"x\"]][[\"layout\"]][[\"xaxis\"]][[\"tickfont\"]][[\"size\"]] = 42 6.3 Plotly basic Sometimes even passing a ggplot object through plotly::plotly_build() does not create the plot we want. Or it’s just too time-consuming to edit the plot in this way. Using plotly itself can be a better option. Plotly is very forgiving. Below we don’t tell plotly what kind of chart we want (such as points or lines) but it still creates a plot. And plotly picks our friend from ggplot, a data points plot. Plotly also generates lots of suggestions to improve the plot. df_red %&gt;% plotly::plot_ly(x = ~date, y = ~sales, color = ~city) ## No trace type specified: ## Based on info supplied, a &#39;scatter&#39; trace seems appropriate. ## Read more about this trace type -&gt; https://plot.ly/r/reference/#scatter ## No scatter mode specifed: ## Setting the mode to markers ## Read more about this attribute -&gt; https://plot.ly/r/reference/#scatter-mode 6.4 plotly (a few more settings) With a few more settings we can turn it into a plotly line plot. df_red %&gt;% plotly::plot_ly(x = ~date, y = ~sales, color = ~city, type = &#39;scatter&#39;, mode = &#39;lines&#39;) 6.5 plotly (bells &amp; whistles) Two more bells and whistles we can add are specifying the colour of the lines and an interactive range slider on the x-axis. df_red %&gt;% plotly::plot_ly(x = ~date, y = ~sales, text = rownames(df_red)) %&gt;% add_lines(color = ~city, colorscale = &quot;set3&quot;) %&gt;% rangeslider() Carson Sievert has created lots of “bells and whistles” plotly plots on the same Texas housing data in his Plotly book. And a few more creative plots here on the Texas data. Below we reproduce some of Sievert’s plots after re-formatting his code according to our three Code style rules described earlier. It makes his examples easier to understand and re-use. In this plot try clicking on one of the lines to highlight one city against all the other cities. # declare `city` as the SQL &#39;query by&#39; column tx &lt;- plotly::highlight_key(data = df, key = ~city) # initiate a plotly object base &lt;- plotly::plot_ly(data = tx, color = I(&quot;black&quot;)) %&gt;% dplyr::group_by(city) # create a time series of median house price base %&gt;% dplyr::group_by(city) %&gt;% plotly::add_lines(x = ~date, y = ~median) In this plot we can look at cities in isolation as well as highlighted against all others. # generally speaking, use a &quot;unique&quot; key for filter, # especially when you have multiple filters! tx &lt;- plotly::highlight_key(df) gg &lt;- tx %&gt;% ggplot2::ggplot() + ggplot2::aes(x = date, y = median, group = city) + ggplot2::geom_line() filter &lt;- crosstalk::bscols( crosstalk::filter_select(&quot;id&quot;, &quot;Select a city&quot;, tx, ~city), plotly::ggplotly(gg, dynamicTicks = TRUE), widths = c(12, 12) ) ## Warning in crosstalk::bscols(crosstalk::filter_select(&quot;id&quot;, &quot;Select a city&quot;, : ## Sum of bscol width units is greater than 12 tx2 &lt;- plotly::highlight_key(data = df, key = ~city, &quot;Select a city&quot;) gg &lt;- tx2 %&gt;% ggplot2::ggplot() + ggplot2::aes(x = date, y = median, group = city) + ggplot2::geom_line() select &lt;- plotly::highlight( plotly::ggplotly(gg, tooltip = &quot;city&quot;), selectize = TRUE, persistent = TRUE ) ## We recommend setting `persistent` to `FALSE` (the default) because persistent selection mode can now be used by holding the shift key (while triggering the `on` event). crosstalk::bscols(filter, select) ## Setting the `off` event (i.e., &#39;plotly_doubleclick&#39;) to match the `on` event (i.e., &#39;plotly_click&#39;). You can change this default via the `highlight()` function. Select a city In this final example Carson adds lots more interactivity to play with. tx &lt;- plotly::highlight_key(df) widgets &lt;- crosstalk::bscols( widths = c(12, 12, 12), crosstalk::filter_select(id = &quot;city&quot;, label = &quot;Cities&quot;, sharedData = tx, group = ~city), crosstalk::filter_slider(id = &quot;sales&quot;, label = &quot;Sales&quot;, sharedData = tx, column = ~sales), crosstalk::filter_checkbox(id = &quot;year&quot;, label = &quot;Years&quot;, sharedData = tx, group = ~year, inline = TRUE) ) ## Warning in crosstalk::bscols(widths = c(12, 12, 12), crosstalk::filter_select(id ## = &quot;city&quot;, : Sum of bscol width units is greater than 12 crosstalk::bscols( widths = c(4, 8), widgets, plotly::plot_ly(data = tx, x = ~date, y = ~median, showlegend = FALSE) %&gt;% plotly::add_lines(color = ~city, colors = &quot;black&quot;) ) Cities Sales Years 2000 2001 2002 2003 2004 2005 2006 2007 2008 2009 2010 2011 2012 2013 2014 2015 6.6 crosstalk Finally, here is a more basic use of crosstalk with plotly that you may find easier to re-use on your data. df_crosstalk &lt;- crosstalk::SharedData$new(data = df, key = ~year) crosstalk::filter_select( id = &quot;year&quot;, label = &quot;Select a year&quot;, allLevels = TRUE, multiple = FALSE, sharedData = df_crosstalk, group = ~ factor(year) ) Select a year df_crosstalk %&gt;% plotly::plot_ly(x = ~date, y = ~sales, color = ~city, type = &#39;scatter&#39;, mode = &#39;lines&#39;) 6.7 apexcharter basic The highcharter package creates interactive charts to the quality you often see on newspaper websites. It can produce great data visualisations like these poll tracking plots. However, highcharter not free to use. ApexCharter is almost as good. It’s inspired by highcharter, and it is free to use. Look how easily we can create a chart with this simple code. df_red %&gt;% apexcharter::apex(type = &quot;line&quot;, mapping = aes(x = date, y = sales, group = city )) 6.8 apexcharter (bells &amp; whistles) To add bells and whistles use the apexcharter reference, It is well laid out with good examples. Below I’ve added several useful settings in a clear code format for you to re-use. df_red %&gt;% apexcharter::apex(aes(x = date, y = sales, group = city), type = &quot;line&quot;) %&gt;% apexcharter::ax_legend(position = &quot;right&quot;) %&gt;% apexcharter::ax_stroke(width = 2) %&gt;% apexcharter::ax_yaxis(title = list(text = &quot;Sales&quot;)) %&gt;% apexcharter::ax_xaxis(labels = list(format = &quot;yyyy&quot;)) %&gt;% apexcharter::ax_labs(title = &quot;House sales in Texas cities&quot;, subtitle = &quot;this is a subtitle&quot;) %&gt;% apexcharter::ax_title(style = list(fontSize = &quot;22px&quot;)) %&gt;% apexcharter::ax_subtitle(style = list(fontSize = &quot;16px&quot;, color = &quot;#BDBDBD&quot;)) %&gt;% apexcharter::ax_chart(zoom = list(enabled = TRUE, type = &quot;xy&quot;)) 6.9 dygraphs basic Dygraphs are another great choice for time series data. Dygraphs require the dataframe to be a time series object. One quick way to convert to a time series object is the tsbox package. df_red_ts &lt;- df_red %&gt;% dplyr::select(date,city,sales) %&gt;% tsbox::ts_xts() df_red_ts %&gt;% dygraphs::dygraph() 6.10 dygraphs (bells &amp; whistles) Below is a bells &amp; whistles version you can play around with as a code template for your own data. The help pages for dygraphs are well laid out. You really only need this one guide to find out how to change all of dygraphs settings. dateWindow &lt;- c(&quot;2014-01-01&quot;, &quot;2015-07-01&quot;) presAnnotation &lt;- function(dygraph, x, text) { dygraph %&gt;% dyAnnotation(x, text, width = 60) } presBankHolidays &lt;- function(dygraph) { dygraph %&gt;% dyEvent(&quot;2014-07-03&quot;, &quot;Independence Day&quot;, labelLoc = &quot;bottom&quot;) %&gt;% dyEvent(&quot;2014-11-26&quot;, &quot;Thanksgiving&quot;, labelLoc = &quot;bottom&quot;) } df_red_ts %&gt;% dygraphs::dygraph(main = &quot;House sales in Texas cities&quot;) %&gt;% # https://github.com/rstudio/dygraphs/issues/80 dyAxis( &quot;y&quot;, label = &quot;Sales&quot;, # http://stackoverflow.com/questions/2901102/how-to-print-a-number-with-commas-as-thousands-separators-in-javascript valueFormatter = &#39;function(d){return d.toString().replace(/\\\\B(?=(\\\\d{3})+(?!\\\\d))/g, &quot;,&quot;);}&#39;, axisLabelFormatter = &#39;function(d){return d.toString().replace(/\\\\B(?=(\\\\d{3})+(?!\\\\d))/g, &quot;,&quot;);}&#39;, axisLabelFontSize = 10, axisLabelWidth = 70 ) %&gt;% dyRangeSelector( height = 60, dateWindow = dateWindow ) %&gt;% dyShading( from = &quot;2014-1-1&quot;, to = &quot;2014-12-31&quot; ) %&gt;% presBankHolidays() %&gt;% dyLegend(width = 600) %&gt;% presAnnotation(&quot;2014-07-01&quot;, text = &quot;2014&quot;) %&gt;% presAnnotation(&quot;2015-06-01&quot;, text = &quot;2015&quot;) %&gt;% dyOptions(colors = RColorBrewer::brewer.pal(8, &quot;Set2&quot;)) %&gt;% dyOptions(drawPoints = TRUE, pointSize = 2) %&gt;% dyLegend( show = &quot;always&quot;, hideOnMouseOut = FALSE ) "],
["animation.html", "Chapter 7 Animation 7.1 ggplot animation 7.2 plotly animation", " Chapter 7 Animation 7.1 ggplot animation Animation is quick to add to ggplot using the gganimate package. I’ve had a play here inspired by a good Tweet of examples. While fun to create and watch, animation should only be used where the movement tells the story more effectively than a static plot. For example, to show change over time. Here is the monthly pattern of house sales we can see the large changes between years. However, the static plot in the Polish your final plot section of this book probably gives the audience a better understanding of the change in sales over each year. # Method from: https://github.com/thomasp85/gganimate/wiki/Temperature-time-series # https://stackoverflow.com/questions/54945861/problems-with-geom-text-and-pausing-the-animation # for each city and year find the sales value in the latest month availalbe # usually this is 12 but sometimes it&#39;s an earlier month label_anim &lt;- df %&gt;% dplyr::group_by(city,year) %&gt;% dplyr::summarise(max_month = max(month)) %&gt;% dplyr::ungroup() %&gt;% dplyr::inner_join(df_red, by = c(&quot;city&quot;=&quot;city&quot;, &quot;year&quot;=&quot;year&quot;, &quot;max_month&quot; = &quot;month&quot;)) %&gt;% dplyr::mutate(label_it = sales) %&gt;% dplyr::select(city,year,max_month,label_it) colors &lt;- c(&quot;Houston&quot; = &quot;#D9717D&quot;, &quot;Dallas&quot; = &quot;#4DB6D0&quot;, &quot;Austin&quot; = &quot;#BECA55&quot;) p &lt;- df %&gt;% dplyr::filter(city %in% c(&quot;Houston&quot;, &quot;Dallas&quot;, &quot;Austin&quot;)) %&gt;% dplyr::left_join(label_anim, by = c(&quot;city&quot; = &quot;city&quot;,&quot;year&quot; = &quot;year&quot;)) %&gt;% ggplot2::ggplot() + ggplot2::aes(x = month, y = sales, colour = city) + ggplot2::geom_line(size = 2) + ggplot2::theme_minimal() + ggplot2::coord_cartesian(clip = &#39;off&#39;) + # allow labels outside of plot ggplot2::theme(legend.position = &quot;none&quot;) + gganimate::transition_states(states = year, transition_length = 3, state_length = 1) + ggplot2::labs(title = &quot;Texas Housing Sales in : {closest_state}&quot;, caption = &quot;Source: ggplot2 package demo data&quot; ) + ggplot2::theme(plot.title = element_text(hjust = 1, vjust = -10, size = 30), panel.grid.major.x = element_blank(), panel.grid.minor.x = element_blank(), strip.text.x = element_text(size = 15), axis.text.x = element_text(size = 15), axis.text.y = element_text(size = 15), plot.caption = element_text( hjust = 0, size = 12, color = &quot;darkgrey&quot; ) ) + ggplot2::scale_color_manual(values = colors) + ggplot2::scale_x_continuous(name = &quot;Month&quot;, limits = c(1,13), breaks = c(1,2,3,4,5,6,7,8,9,10,11,12), label = c(&quot;Jan&quot;,&quot;Feb&quot;,&quot;Mar&quot;,&quot;Apr&quot;,&quot;May&quot;,&quot;Jun&quot;,&quot;Jul&quot;,&quot;Aug&quot;,&quot;Sep&quot;,&quot;Oct&quot;,&quot;Nov&quot;,&quot;Dec&quot;)) + ggplot2::geom_text(aes(x = max_month, y = label_it, label = city), hjust = 0, size = 8) gganimate::animate(p, width = 900, height = 600, end_pause = 10, fps = 20, rewind = FALSE, duration = 15) gganimate::anim_save(filename = &quot;housing.gif&quot;) 7.2 plotly animation Carson Sievert’s book shows us how to animate in plotly. The code to animate a plotly plot is easier than for ggplot. Simply specify which column to animate over in the frame argument of plotly::add_lines(). df_red %&gt;% plotly::plot_ly(alpha = 1) %&gt;% plotly::add_lines( x = ~month, y = ~sales, frame = ~year, # this single line of code turns it into an animation! color = ~factor(city), line = list(simplify = FALSE) ) %&gt;% plotly::layout(yaxis = list(title = &quot;Sales&quot;)) ## Warning in RColorBrewer::brewer.pal(N, &quot;Set2&quot;): n too large, allowed maximum for palette Set2 is 8 ## Returning the palette you asked for with that many colors ## Warning in RColorBrewer::brewer.pal(N, &quot;Set2&quot;): n too large, allowed maximum for palette Set2 is 8 ## Returning the palette you asked for with that many colors Here we play around with the animation style. df_red %&gt;% plotly::plot_ly(alpha = 1) %&gt;% plotly::add_lines( x = ~month, y = ~sales, frame = ~year, color = ~factor(city), line = list(simplify = FALSE) ) %&gt;% plotly::layout(yaxis = list(title = &quot;Sales&quot;)) %&gt;% plotly::animation_opts(frame = 1000, # easing = &quot;elastic&quot;, easing = &quot;bounce&quot;, redraw = FALSE) %&gt;% plotly::animation_slider(currentvalue = list(prefix = &quot;YEAR &quot;, font = list(color=&quot;blue&quot;))) ## Warning in RColorBrewer::brewer.pal(N, &quot;Set2&quot;): n too large, allowed maximum for palette Set2 is 8 ## Returning the palette you asked for with that many colors ## Warning in RColorBrewer::brewer.pal(N, &quot;Set2&quot;): n too large, allowed maximum for palette Set2 is 8 ## Returning the palette you asked for with that many colors "],
["process-mining.html", "Chapter 8 Process Mining 8.1 What is Process Mining? 8.2 The event log 8.3 Visualise the event log 8.4 Can we predict the age of a case? 8.5 Process Discovery algorithms", " Chapter 8 Process Mining 8.1 What is Process Mining? Process mining techniques can visualise the many paths that cases can take in organisations. For example, a patient being treated in a hospital or a complaint handled by a train company. However, seeing every path cases take in a process map is often overwhelming. Fortunately, there are many ways to simplify process maps we explore in this chapter. Data science techniques can also be applied to process mined data. For example, predicting the time it will take a case to complete a process, or recommending the next best step that should shorten the time to a case completing. The Coursera Process Mining course and accompanying Process Mining: Data Science in Action book provide a detailed background to these techniques and their applications in different industries. There is also a free to read Process Mining in Practice book by the same author. The minimum data needed for process mining are two columns that record: Activity: The activities (or events) that took place in the process. Date: The date (and perhaps time) each activity occurred. For example, knowing how and when a complaint is handled in different ways are the two minimum pieces of information needed for process mining in data. Three further data items will offer more insight: Resource: The person (or system) that carried out each activity in the process. This is known as the “resource”. Lifecycle: The transaction lifecycle of the case at each activity. For example, is the case at “start”, “in progress”, or “complete”. State: The state the case was moved into by each activity. This is usually a greater level of detail below the broad transaction lifecycle categories. For example, the data could tell us the customer is the resource who carried out the payment activity which moves its transaction lifecycle to “complete” and into the state “paid”. 8.2 The event log 8.2.1 Understanding the event log The eventdataR package contains both artificial and real life event logs. It comes from a family of process mining packages called bupaR which stands for Business Process Analysis with R. The bupaR cheatsheet summaries the key functions from the family of packages in one clear page. Let’s walk through key process mining techniques in a logical order using the hospital_billing event log from eventdataR. How it was created and anonymised is described here. Also, the academic paper Data-driven process discovery: revealing conditional infrequent behavior from event logs explores the same hospital billing event log in figure 6. The example hospital billing event log has already been created for us. Putting it into the utils::str() function shows us the structure of this R object. The output shows that log holds number of cases, activities, resources, and “traces”. Traces are the unique paths cases take through different activities. Resources are typically the names of people who carried out each activity. utils::str(eventdataR::hospital_billing) ## Classes &#39;eventlog&#39;, &#39;tbl_df&#39;, &#39;tbl&#39; and &#39;data.frame&#39;: 49951 obs. of 25 variables: ## $ case_id : chr &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; ... ## $ activity : Factor w/ 18 levels &quot;BILLED&quot;,&quot;CHANGE DIAGN&quot;,..: 12 9 14 6 1 12 7 12 9 14 ... ## $ lifecycle : Factor w/ 1 level &quot;complete&quot;: 1 1 1 1 1 1 1 1 1 1 ... ## $ resource : Factor w/ 1150 levels &quot;ResA&quot;,&quot;ResAA&quot;,..: 1 NA NA NA 46 1 91 1 NA NA ... ## $ timestamp : POSIXct, format: &quot;2012-12-16 19:33:10&quot; &quot;2013-12-15 19:00:37&quot; ... ## $ actorange : chr NA NA NA &quot;false&quot; ... ## $ actred : chr NA NA NA &quot;false&quot; ... ## $ blocked : chr &quot;false&quot; NA NA NA ... ## $ casetype : chr &quot;A&quot; NA NA NA ... ## $ closecode : chr NA &quot;A&quot; NA NA ... ## $ diagnosis : chr &quot;A&quot; NA NA NA ... ## $ flaga : chr &quot;false&quot; NA NA NA ... ## $ flagb : chr &quot;false&quot; NA NA NA ... ## $ flagc : chr NA NA NA &quot;false&quot; ... ## $ flagd : chr &quot;true&quot; NA NA NA ... ## $ iscancelled : chr &quot;false&quot; NA NA NA ... ## $ isclosed : chr &quot;true&quot; NA NA NA ... ## $ msgcode : chr NA NA NA NA ... ## $ msgcount : int NA NA NA 0 NA NA NA NA NA NA ... ## $ msgtype : chr NA NA NA NA ... ## $ speciality : chr &quot;A&quot; NA NA NA ... ## $ state : chr &quot;In progress&quot; &quot;Closed&quot; &quot;Released&quot; NA ... ## $ version : chr NA NA NA &quot;A&quot; ... ## $ activity_instance_id: chr &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ... ## $ .order : int 1 2 3 4 5 6 7 8 9 10 ... ## - attr(*, &quot;case_id&quot;)= chr &quot;case_id&quot; ## - attr(*, &quot;activity_id&quot;)= chr &quot;activity&quot; ## - attr(*, &quot;activity_instance_id&quot;)= chr &quot;activity_instance_id&quot; ## - attr(*, &quot;lifecycle_id&quot;)= chr &quot;lifecycle&quot; ## - attr(*, &quot;resource_id&quot;)= chr &quot;resource&quot; ## - attr(*, &quot;timestamp&quot;)= chr &quot;timestamp&quot; Also, at the bottom of the output above, the event log has six additional attributes: case_id a unique case id to tell us which activity rows belong to each case. activity a description of what happened. activity_instance_id a unique id for each activity. lifecycle the status of the case at each activity such as “complete”. resource who did the activity. timestamp when the activity happened. We return just those attributes below.. str(base::attributes(eventdataR::hospital_billing)) ## List of 9 ## $ names : chr [1:25] &quot;case_id&quot; &quot;activity&quot; &quot;lifecycle&quot; &quot;resource&quot; ... ## $ row.names : int [1:49951] 1 2 3 4 5 6 7 8 9 10 ... ## $ case_id : chr &quot;case_id&quot; ## $ activity_id : chr &quot;activity&quot; ## $ activity_instance_id: chr &quot;activity_instance_id&quot; ## $ lifecycle_id : chr &quot;lifecycle&quot; ## $ resource_id : chr &quot;resource&quot; ## $ timestamp : chr &quot;timestamp&quot; ## $ class : chr [1:4] &quot;eventlog&quot; &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; We would typically expect cases to be in one of several states as they pass through a process. Below we can see all the values of the state column. It appears that state has not been used to create a lifecycle attribute in the event log that would define when the case is “complete”. Instead, all cases have been marked as “complete” at every activity. eventdataR::hospital_billing %&gt;% dplyr::count(state) ## # A tibble: 11 x 2 ## state n ## &lt;chr&gt; &lt;int&gt; ## 1 Billable 499 ## 2 Billed 7432 ## 3 Check 1 ## 4 Closed 7886 ## 5 Empty 179 ## 6 In progress 17809 ## 7 Invoice rejected 229 ## 8 Rejected 70 ## 9 Released 7909 ## 10 Unbillable 84 ## 11 &lt;NA&gt; 7853 eventdataR::hospital_billing %&gt;% dplyr::count(lifecycle) ## # A tibble: 1 x 2 ## lifecycle n ## &lt;fct&gt; &lt;int&gt; ## 1 complete 49951 This heatmap counts the activities and the state they were in at the time the activity was carried out. eventdataR::hospital_billing %&gt;% dplyr::count(activity,state) %&gt;% ggplot2::ggplot() + ggplot2::aes(x = state, y = activity, fill = n) + ggplot2::geom_tile(width=0.9, height=0.9)+ ggplot2::geom_text(aes(label = base::ifelse(n&gt;0, base::format(n, big.mark = &quot;,&quot;, scientific = FALSE), NA)), size = 3) + ggplot2::scale_fill_gradient(low = &quot;white&quot;, high = &quot;red&quot;, limits = c(-500,12000)) + ggplot2::theme_minimal() + ggplot2::theme(axis.text.x = element_text(angle = 60, hjust = 1), legend.position = &quot;none&quot;, axis.title.y = element_text(angle = 0, vjust = 0.5)) + ggplot2::labs(x = &quot;State&quot;, y = &quot;Activity&quot;, title = &quot;Case activities and the case state the activity creates&quot;) The states Billed, Closed and Released are almost entirely triggered by one activity (BILLED, FIN, and RELEASE respectively). Only the state In progress is triggered by more than one activity, though it is almost entirely the activities NEW and CHANGE DIAGN, followed by DELETE, REOPEN in smaller numbers. With more domain knowledge from an expert who works with the real life process it would be possible to create a useful lifecycle attribute. For example, a sensible categorisation might be to: assign the value of lifecycle to “complete” for rows with the state values Billed, Closed, Invoice rejected, Rejected, Released or Unbillable. assign the value of lifecycle to “in progress” for rows with the state values Billable and In progress, and, assign the value of lifecycle to “start” when the activity is NEW. Some state values are NA. These missing values could be imputed with the last known value of state when it was not NA. 8.3 Visualise the event log To quickly and intuitively understand the hospital billing event log we can explore it like any other data frame or tibble in R. First we view all the events for three cases using dplyr verbs and DT::datatable(). eventdataR::hospital_billing %&gt;% dplyr::filter(case_id %in% c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;)) %&gt;% dplyr::select(case_id,activity,resource,timestamp,state,lifecycle) %&gt;% dplyr::arrange(case_id,timestamp) %&gt;% DT::datatable( caption = &quot;Top &quot;, filter = &quot;top&quot;, extensions = c(&quot;FixedColumns&quot;, &quot;Buttons&quot;), options = list(columnDefs = list(list(width = &quot;150px&quot;, targets = c(4)))) ) In this table the cases A and C have a final activity of BILLED. The state that the BILLED activity moves the cases into is also called Billed. In contrast, for case B the BILLED activity was not carried out. Its final state in the log is DELETE. Perhaps the hospital bill for this person was withdrawn or cancelled for some reason? 8.3.1 Process map We can quickly create process maps from an event log using the function processmapR::process_map(). eventdataR::hospital_billing %&gt;% processmapR::process_map() ## Warning: Prefixing `UQ()` with the rlang namespace is deprecated as of rlang 0.3.0. ## Please use the non-prefixed form or `!!` instead. ## ## # Bad: ## rlang::expr(mean(rlang::UQ(var) * 100)) ## ## # Ok: ## rlang::expr(mean(UQ(var) * 100)) ## ## # Good: ## rlang::expr(mean(!!var * 100)) ## ## This warning is displayed once per session. This process map displays the entire event log to show every activity that has occurred and in what order. Plotting the detail of every case path (or trace) is often overwhelming. The process can appear more complex than it really is. Maps that are too detailed have been called “spaghetti-like” by the authors of an algorithmic method we will explore later that is one of several ways to simplify process maps. Process maps can be simplified in many ways. Each method helps us understand both typical and rare case paths more easily. A basic simplification is to create the process map only for a small number of cases. Below only cases A, B and C from the table above are mapped. eventdataR::hospital_billing %&gt;% dplyr::filter(case_id %in% c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;)) %&gt;% processmapR::process_map() If no arguments are included in the processmapR::process_map() function the number in the box (or node) and its colour are how many cases have had that activity carried out. Darker colours represent more cases. The number on the arrows (or edges) and their thickness represent how many cases have passed between two activities in the direction of the arrow. We can also subset event logs using the edeaR::trace_frequency() function so that the process map shows only the most common paths cases take . Let’s filter the log to contain only cases that have followed the top 90% most frequent paths, then pipe (%&gt;%) that reduced log it into thee process map function. eventdataR::hospital_billing %&gt;% edeaR::filter_trace_frequency(percentage = 0.9) %&gt;% processmapR::process_map() The default values on a process map are the the number of cases. The process map below uses a custom profile. We have adjusted the the numbers inside each box (or node) to include both the absolute number of times the activity was carried out, and in brackets below is the percentage of those activities among all the activities carried out. This means that the percentages in the brackets across all the boxes in the map sum to 100%. The labels on the arrows (or edges) have also been altered. They now show the absolute number of times cases move from each activity to the next in the direction of the arrow. The percentages in brackets on all the arrows coming out of each box will sum to 100%. eventdataR::hospital_billing %&gt;% edeaR::filter_trace_frequency(percentage = 0.9) %&gt;% processmapR::process_map(type_nodes = processmapR::frequency(&quot;absolute&quot;), sec_nodes = processmapR::frequency(&quot;relative&quot;), type_edges = processmapR::frequency(&quot;absolute&quot;), sec_edges = processmapR::frequency(&quot;relative&quot;), rankdir = &quot;TB&quot;) Next we alter the value in the brackets in the box labels to show the unique number of cases passing through that activity. The number above it (not in brackets) is usually higher for this event log. This tells us some cases must pass through that activity more than once. We also alter the label on the arrows (or edges) inside the brackets to show the median average time between the two activities. The thickness of the arrow still represents the percentage of cases moving from that node. eventdataR::hospital_billing %&gt;% edeaR::filter_trace_frequency(percentage = 0.9) %&gt;% processmapR::process_map(type_nodes = processmapR::frequency(&quot;absolute&quot;), sec_nodes = processmapR::frequency(&quot;absolute_case&quot;), type_edges = processmapR::frequency(&quot;relative&quot;), sec_edges = processmapR::performance(FUN = median, units = &quot;days&quot;, flow_time = &quot;inter_start_time&quot; ), rankdir = &quot;TB&quot;) 8.3.2 Trace explorer Another way to visualise the paths that cases take is with the trace explorer. This plot displays each trace (or path) sorted in descending order of frequency. The coloured squares represent the activities cases pass through in order from left to right. We have also filtered the log first to show only the top 90% most frequent paths to mirror the process map filter above. eventdataR::hospital_billing %&gt;% edeaR::filter_trace_frequency(percentage = 0.9) %&gt;% processmapR::trace_explorer(coverage = 1, type = &quot;frequent&quot;, .abbreviate = T) Compared to the process map, the trace explorer is easier for domain experts to identify case paths that are unexpected or not allowed. This is known as “conformance checking” that is also explored later. The Trace Explorer chart also allows easy identification and exploration of repeated activities that may also be unusual or unexpected. For example, in the process maps above the BILLED activity occurs more than once for some cases. We can see this where the unique number of cases in brackets in each box is a lower number than the number of cases passing through the activity that is shown above it. Below we filter the log first to only include cases where the BILLED activity occurred tow or more times. We also trim the path (or trace) to only show the first and last time the BILLED activity occurs. eventdataR::hospital_billing %&gt;% processcheckR::check_rule(processcheckR::contains(activity = &quot;BILLED&quot;, n = 2)) %&gt;% tidylog::filter(contains_BILLED_2 == TRUE) %&gt;% edeaR::filter_trim(start_activities = &quot;BILLED&quot;, end_activities = &quot;BILLED&quot;) %&gt;% processmapR::trace_explorer(coverage = 0.8, type = &quot;frequent&quot;, .abbreviate = T) Also, as the trace explorer is a ggplot chart, we are also able to alter the plot format in two ways. We can save it as an R object and then adjust elements of that nested list directly. And we can add on additional ggplot format settings using using the + symbol. Both methods are demonstrated below. p &lt;- eventdataR::hospital_billing %&gt;% processcheckR::check_rule(processcheckR::contains(activity = &quot;BILLED&quot;, n = 2)) %&gt;% tidylog::filter(contains_BILLED_2 == TRUE) %&gt;% edeaR::filter_trim(start_activities = &quot;BILLED&quot;, end_activities = &quot;BILLED&quot;) %&gt;% processmapR::trace_explorer(coverage = 0.8, type = &quot;frequent&quot;, .abbreviate = F) + ggplot2::labs(title = &quot;Most frequent paths where the &#39;BILLED&#39; activity is repeated&quot;) ## filter: removed 46,721 rows (94%), 3,230 rows remaining p$data$relative_frequency &lt;- round(p$data$relative_frequency,2) p$theme$strip.background$fill &lt;- &quot;lightgrey&quot; p$theme$strip.text$colour &lt;- &quot;black&quot; p 8.3.3 Conformance checking We can also use processcheckR to identify which traces either follow or break certain rules. For example, below we narrow down the process map to only show cases that have the CHANGE_DIAGN activity carried out. This change of diagnosis activity we can imagine may be a significant event in a hospital with an impact on the final bill so would be worth checking that certain agreed processes are followed. This might include detecting both mistakes in the process and potential fraudulent activity. eventdataR::hospital_billing %&gt;% edeaR::filter_trace_frequency(percentage = 0.9) %&gt;% processcheckR::filter_rules(r1 = processcheckR::and(&quot;CHANGE DIAGN&quot;,&quot;REOPEN&quot;), r2 = processcheckR::succession(&quot;NEW&quot;,&quot;CHANGE DIAGN&quot;)) %&gt;% processmapR::process_map(type_nodes = processmapR::frequency(&quot;absolute&quot;), sec_nodes = processmapR::frequency(&quot;absolute_case&quot;), type_edges = processmapR::frequency(&quot;relative&quot;), sec_edges = processmapR::performance(FUN = median, units = &quot;days&quot;, flow_time = &quot;inter_start_time&quot; ), rankdir = &quot;TB&quot;) 8.3.4 Dotted chart The dotted chart is similar in style to the trace explorer. It also displays activities in the order they occur horizontally. The main difference is that each line of dots in the dotted chart represents an individual case. The trace explorer instead displays the unique paths for one or more cases. In the dotted chart below the x axis argument is set so that the position of each dot horizontally is the absolute date when each activity occurred. Also, the horizontal lines are sorted in descending order of the total trace time (or duration) of each case. The shortest duration case is at the top and the longest at the bottom. eventdataR::hospital_billing %&gt;% edeaR::filter_trace_frequency(percentage = 0.9) %&gt;% processmapR::dotted_chart(x = &quot;absolute&quot;, sort = &quot;duration&quot;) ## Joining, by = &quot;case_id&quot; This dotted chart is very useful for insight into the hospital billing process. At the top of the plot, the pink dots show many cases which begin in early 2013 with the NEW activity have no further activities recorded. This short single activity path can also be seen in the first process map we drew in this chapter. It is the arrow that goes from the NEW box directly to the END circle without passing through any other activity boxes. However, this short path is much easier to identify with a dotted chart. It also reveals the date range in which it occurs most often. The only way to identify changes in case paths over time with the process map is to animate, or draw multiple maps from event logs that are filtered with different time periods. All of the NEW activities occur in a narrow time range in early 2013. This strongly suggests the data was extracted from the live system by selecting only cases where the NEW activity occurred in early 2013. Again, because the function processmapR::dotted_chart() creates a ggplot chart we can alter how it appears by adding ggplot settings or updating the R object. For example, a useful change we make to this dotted chart is to show monthly breaks on the x-axis. # Put the dotted chart into an R object p &lt;- eventdataR::hospital_billing %&gt;% edeaR::filter_trace_frequency(percentage = 0.9) %&gt;% processmapR::dotted_chart(x = &quot;absolute&quot;, sort = &quot;duration&quot;) ## Joining, by = &quot;case_id&quot; # change the format of the x axis to a date p$data$start &lt;- as.Date(p$data$start) p + ggplot2::scale_x_date(date_breaks = &quot;1 month&quot;, labels = scales::date_format(&quot;%b %y&quot;)) + ggplot2::theme_minimal() + ggplot2::theme( axis.text.x = element_text( angle = 60, hjust = 1, size = 9 )) + ggplot2::labs( title = &quot;Month on which NEW activity occurred&quot;, x = &quot;Date&quot;, y = &quot;Number of activities&quot; ) + ggplot2::guides(colour = guide_legend(override.aes = list(size=5))) Let’s further explore the activity over time. The bar plot below counts the number of occurrences of the NEW activity in each month. We can see all the NEW activities occurred between January and April 2013. min &lt;- lubridate::as_date(base::min(eventdataR::hospital_billing$timestamp)) max &lt;- lubridate::as_date(base::max(eventdataR::hospital_billing$timestamp)) eventdataR::hospital_billing %&gt;% edeaR::filter_activity(activities = c(&quot;NEW&quot;)) %&gt;% dplyr::mutate(day = lubridate::as_date(timestamp), month = base::cut(day, &quot;month&quot;), month = lubridate::as_date(month)) %&gt;% dplyr::count(month) %&gt;% ggplot2::ggplot() + ggplot2::aes(x = month, y = n) + ggplot2::geom_bar(stat = &quot;identity&quot;) + ggplot2::scale_x_date(date_breaks = &quot;1 month&quot;, labels = scales::date_format(&quot;%b %y&quot;), limits = c(min,max)) + ggplot2::theme_minimal() + ggplot2::theme( axis.text.x = element_text( angle = 60, hjust = 1, size = 9 )) + ggplot2::labs( title = &quot;Month on which NEW activity occurred&quot;, x = &quot;Date&quot;, y = &quot;Number of activities&quot; ) ## Warning: Removed 1 rows containing missing values (position_stack). Next we sort the order of the rows of dots by the start date. p &lt;- eventdataR::hospital_billing %&gt;% edeaR::filter_trace_frequency(percentage = 0.9) %&gt;% processmapR::dotted_chart(x = &quot;absolute&quot;, sort = &quot;start&quot;) ## Joining, by = &quot;case_id&quot; # change the format of the x axis to a date p$data$start &lt;- as.Date(p$data$start) p + ggplot2::scale_x_date(date_breaks = &quot;1 month&quot;, labels = scales::date_format(&quot;%b %y&quot;)) + ggplot2::theme_minimal() + ggplot2::theme( axis.text.x = element_text( angle = 60, hjust = 1, size = 9 )) + ggplot2::labs( title = &quot;Month on which NEW activity occurred&quot;, x = &quot;Date&quot;, y = &quot;Number of activities&quot; ) + ggplot2::guides(colour = guide_legend(override.aes = list(size=5))) This reveals two distinct groups of cases, one where the BILLED activity (green dots) often occurs during autumn 2013, and the other where BILLED often occurs during spring 2014. However, with so many dots plotted, it is hard to follow the path for a case individually. This is known as “over-plotting”. We can reduce over-plotting by sampling the cases with dplyr first. We can also use the plotly version of a dotted chart and hover our mouse pointer over each dot. This reveals the case id making is possible to follow the path of individual cases by hand. eventdataR::hospital_billing %&gt;% edeaR::filter_trace_frequency(percentage = 0.9) %&gt;% dplyr::sample_n(size = 100) %&gt;% processmapR::plotly_dotted_chart(x = &quot;absolute&quot;, sort = &quot;start&quot;) ## Joining, by = &quot;case_id&quot; 8.3.5 Resource exploration The bupaR visualisations explored in this chapter so far are about the case, telling us which activities were carried out and in what order. However, we also know who carried out each activity. Below we create a small data set of 30 randomly selected complete cases that begin with the NEW activity and end with the BILLED activity. We then view the activities for these 30 cases in a process map. limited &lt;- eventdataR::hospital_billing %&gt;% edeaR::filter_endpoints(start_activities = &quot;NEW&quot;, end_activities = &quot;BILLED&quot;) %&gt;% dplyr::sample_n(30) limited %&gt;% processmapR::process_map() Let’s now visualise who carried out each of those activities (the resource) in a resource process map using processmapR::resourcemap(). We also add a new factor level to the resource column where no resource has been recorded. This is so that the resource map draws fully and does not stop where the resource information is missing leaving orphaned nodes (or boxes). limited$resource = factor(limited$resource, levels=c(levels(limited$resource), &quot;missing&quot;)) limited$resource[is.na(limited$resource)] = &quot;missing&quot; limited %&gt;% processmapR::resource_map(type_nodes = processmapR::frequency(&quot;absolute&quot;), sec_nodes = processmapR::frequency(&quot;absolute_case&quot;), type_edges = processmapR::frequency(&quot;absolute&quot;), sec_edges = processmapR::performance(FUN = median, units = &quot;days&quot;, flow_time = &quot;inter_start_time&quot; ), rankdir = &quot;TB&quot;) We can see from the resource process map above that the resource is often missing for certain activities. In the heatmap below, for these 30 cases, we can see on the top row are the count activities where the resource information is missing. limited %&gt;% edeaR::resource_frequency(&quot;resource-activity&quot;) %&gt;% plot() We can also plot how many resources were used on each case for the entire log using the edeaR::resource_frequency() function. eventdataR::hospital_billing %&gt;% edeaR::resource_frequency(level = &quot;case&quot;) %&gt;% plot() ## Warning: Factor `resource` contains implicit NA, consider using ## `forcats::fct_explicit_na` ## Warning: Factor `resource` contains implicit NA, consider using ## `forcats::fct_explicit_na` And use the edeaR::resource_specialisation() function to see if some resources specialise in certain activities across all of the cases. eventdataR::hospital_billing %&gt;% edeaR::resource_specialisation(level = &quot;activity&quot;) %&gt;% plot() ## Warning: Factor `resource` contains implicit NA, consider using ## `forcats::fct_explicit_na` ## Warning: Factor `resource` contains implicit NA, consider using ## `forcats::fct_explicit_na` Finally, using the processmapR::resource_matrix() we can see which resources (the antecedent) directly pass a case to another resource (consequent) to carry out the next activity just for our limited set of 30 cases. rm &lt;- limited %&gt;% processmapR::resource_matrix(type = &quot;absolute&quot;) p1 &lt;- rm %&gt;% ggplot2::ggplot() + ggplot2::aes(x = consequent, y = antecedent, fill = n) + ggplot2::geom_tile()+ ggplot2::geom_text(aes(label = base::ifelse(n&gt;0, base::format(n, big.mark = &quot;,&quot;, scientific = FALSE), NA)), size = 3) + ggplot2::scale_fill_gradient(low = &quot;white&quot;, high = &quot;red&quot;) + ggplot2::theme_minimal() + ggplot2::theme(axis.text.x = element_text(angle = 60, hjust = 1), legend.position = &quot;none&quot;, axis.title.y = element_text(angle = 0, vjust = 0.5)) + ggplot2::labs(x = &quot;Consequent&quot;, y = &quot;Antecedent&quot;) p1 8.3.6 Filter interactively within RStudio In the central section of the bupaR cheatsheet all of the edeaR event and case filter functions are also available as interactive Shiny Gadgets. For example, running the function edeaR::ifilter_endpoints() within RStudio will create a dialog from which you can select the start and end activities and filter the log. filter_end_points &lt;- edeaR::ifilter_endpoints(eventdataR::hospital_billing) filter_end_points %&gt;% processmapR::process_map() We can then put this filtered log filter_end_points into a process map. 8.3.7 Bespoke exploration Further bespoke explorations are described in this process mining blog post.It includes an example of creating an interruption index to tell us how much a resource “toggles” between multiple cases, and a heatmap to show peak periods during the day. Let’s re-create the hourly heatmap for our hospital billing data. We can see that some activities are more common at lunchtime (e.g. STORNO and MANUAL), and some occur in the early hours of the morning (e.g. CODE ERROR). Perhaps the very early activities outside of normal office hours are automatic system activities? t &lt;- eventdataR::hospital_billing %&gt;% dplyr::mutate(hour = lubridate::hour(timestamp)) %&gt;% dplyr::count(activity, hour) %&gt;% dplyr::group_by(activity) %&gt;% dplyr::mutate(nn = sum(n)) %&gt;% dplyr::ungroup() %&gt;% dplyr::mutate(percent= ((n/nn)*100)) t %&gt;% ggplot2::ggplot(aes(x = hour, y = activity, fill=percent)) + ggplot2::geom_tile(size=.5, color=&quot;white&quot;) + ggplot2::scale_fill_gradient(low = &quot;lightblue&quot;, high = &quot;red&quot;, limits = c(0,50)) + ggplot2::geom_text(aes(label = base::ifelse(percent&gt;0, round(percent,0), NA)), size = 4, #fontface = &quot;bold&quot; ) + ggplot2::theme_classic()+ ggplot2::theme(legend.position = &quot;none&quot;) + ggplot2::labs(x=&quot;24 hour Clock&quot;, y=&quot;&quot;, title= &quot;In what hour does each hospital billing activity occur?&quot;, subtitle = &quot;Percentage in each hour for each activity&quot;, fill=&quot;%&quot;) + ggplot2::scale_y_discrete(limits = rev(levels(eventdataR::hospital_billing$activity))) + ggplot2::scale_x_continuous(breaks = scales::pretty_breaks(n = 12)) 8.3.8 Creating your own event log In the visualisations so far we have used the hospital billing event log that has been created for us. Creating our own log from raw events data is straightforward. Follow the bupaR “create event log” guidance. When creating an event log, as well as the activity name and a timestamp, each activity row needs its own globally unique ID, the resource who carried out each activity and a lifecycle status. The lifecycle would typically describe if a case has just started, is in-progress, or is complete when each activity occurs. If a unique activity ID and a lifecycle status are missing they can easily be artifically created using a row count for the ID and by assigning the status to a single value such as “complete” or “NA”. If Who did each activity (the resource) may also be missing. Resource can also simply be assigned as a blank “NA” column. The example below demonstrates creating an event log with minimum amount of information required to draw a process map with the activity id, resource, and status created artificially before the event log is built with the bupaR::eventlog() function. patients &lt;- data.frame(stringsAsFactors=FALSE, patient = c(&quot;John Doe&quot;, &quot;John Doe&quot;, &quot;John Doe&quot;, &quot;John Doe&quot;, &quot;John Doe&quot;, &quot;John Doe&quot;, &quot;John Doe&quot;, &quot;John Doe&quot;, &quot;John Doe&quot;), activity = c(&quot;check-in&quot;, &quot;surgery&quot;, &quot;surgery&quot;, &quot;surgery&quot;, &quot;treatment&quot;, &quot;treatment&quot;, &quot;surgery&quot;, &quot;surgery&quot;, &quot;check-out&quot;), timestamp = c(&quot;2017-05-10 08:33:26&quot;, &quot;2017-05-10 08:38:21&quot;, &quot;2017-05-10 08:53:16&quot;, &quot;2017-05-10 09:25:19&quot;, &quot;2017-05-10 10:01:25&quot;, &quot;2017-05-10 10:35:18&quot;, &quot;2017-05-10 10:41:35&quot;, &quot;2017-05-10 11:05:56&quot;, &quot;2017-05-11 14:52:36&quot;)) example_log_1 &lt;- patients %&gt;% #a data.frame with the information in the table above dplyr::mutate(activity_instance = 1:n(), resource = NA, status = &quot;complete&quot;, timestamp = anytime::anytime(timestamp)) %&gt;% bupaR::eventlog( case_id = &quot;patient&quot;, activity_id = &quot;activity&quot;, activity_instance_id = &quot;activity_instance&quot;, lifecycle_id = &quot;status&quot;, timestamp = &quot;timestamp&quot;, resource_id = &quot;resource&quot; ) example_log_1 %&gt;% processmapR::process_map() After creating an event log you may need to add additional columns with useful information. This is known as “enrichment”. However, this breaks the attributes you have mapped using the bupaR::eventlog() function and the event log cannot be used with bupaR functions. Rather than using the bupar::eventlog() function to recreate the event log, which is time consuming, it’s much faster to use bupar::mapping() to save the attribute mappings and then bupar::re_map() to add them back to the broken event log. The time saving can be significant for large event logs that can take 5 to 10 mins to re-create whereas the re_map takes only a few seconds. For example, below we create an event log using the same example data in the bupaR guidance. patients &lt;- data.frame(stringsAsFactors=FALSE, patient = c(&quot;John Doe&quot;, &quot;John Doe&quot;, &quot;John Doe&quot;, &quot;John Doe&quot;, &quot;John Doe&quot;, &quot;John Doe&quot;, &quot;John Doe&quot;, &quot;John Doe&quot;, &quot;John Doe&quot;), activity = c(&quot;check-in&quot;, &quot;surgery&quot;, &quot;surgery&quot;, &quot;surgery&quot;, &quot;treatment&quot;, &quot;treatment&quot;, &quot;surgery&quot;, &quot;surgery&quot;, &quot;check-out&quot;), timestamp = c(&quot;2017-05-10 08:33:26&quot;, &quot;2017-05-10 08:38:21&quot;, &quot;2017-05-10 08:53:16&quot;, &quot;2017-05-10 09:25:19&quot;, &quot;2017-05-10 10:01:25&quot;, &quot;2017-05-10 10:35:18&quot;, &quot;2017-05-10 10:41:35&quot;, &quot;2017-05-10 11:05:56&quot;, &quot;2017-05-11 14:52:36&quot;), status = c(&quot;complete&quot;, &quot;schedule&quot;, &quot;start&quot;, &quot;complete&quot;, &quot;start&quot;, &quot;complete&quot;, &quot;start&quot;, &quot;complete&quot;, &quot;complete&quot;), resource = c(&quot;Samantha&quot;, &quot;Danny&quot;, &quot;Richard&quot;, &quot;Richard&quot;, &quot;Danny&quot;, &quot;Danny&quot;, &quot;William&quot;, &quot;William&quot;, &quot;Samantha&quot;) ) resource_experience_years &lt;- data.frame(stringsAsFactors=FALSE, resource = c(&quot;Samantha&quot;, &quot;Danny&quot;, &quot;Richard&quot;,&quot;William&quot;, &quot;Samantha&quot;), years_experience = c(2, 5, 0.2, 6, 8.9)) example_log_1 &lt;- patients %&gt;% #a data.frame with the information in the table above dplyr::mutate(activity_instance = 1:n(), timestamp = anytime::anytime(timestamp)) %&gt;% eventlog( case_id = &quot;patient&quot;, activity_id = &quot;activity&quot;, activity_instance_id = &quot;activity_instance&quot;, lifecycle_id = &quot;status&quot;, timestamp = &quot;timestamp&quot;, resource_id = &quot;resource&quot; ) # Save event log Mappings example_log_1_mapping &lt;- bupaR::mapping(example_log_1) # enrich and filter the log example_log_1 &lt;- example_log_1 %&gt;% dplyr::left_join(resource_experience_years, by = c(&quot;resource&quot; = &quot;resource&quot;)) ## Warning: Column `resource` joining factor and character vector, coercing into ## character vector # the log is broken so won&#39;t work with a process map example_log_1 %&gt;% processmapR::process_map() ## Error: Only strings can be converted to symbols To fix the log so that it can be used to draw a process map , below we remap the log attributes with the bupaR::remap() function. We re-map the attributes we saved in the code above using the buparR::mapping() function. After remapping We can draw a process map from the re-mapped event log. # re-map the atributes example_log_1 &lt;- example_log_1 %&gt;% bupaR::re_map(example_log_1_mapping) # the log attributes have been re-mapped so it will create a process map example_log_1 %&gt;% processmapR::process_map() 8.4 Can we predict the age of a case? Perhaps there is a feature in the data that can explain why there are two time periods in which the activity BILLED occurs? This pattern is seen clearly if we visualise the number of times the BILLED activity occurs in each month. eventdataR::hospital_billing %&gt;% edeaR::filter_activity(activities = c(&quot;BILLED&quot;)) %&gt;% dplyr::mutate(day = lubridate::as_date(timestamp), month = base::cut(day, &quot;month&quot;), month = lubridate::as_date(month)) %&gt;% dplyr::count(month) %&gt;% ggplot2::ggplot() + ggplot2::aes(x = month, y = n) + ggplot2::geom_bar(stat = &quot;identity&quot;) + ggplot2::scale_x_date(date_breaks = &quot;1 month&quot;, labels = scales::date_format(&quot;%b %y&quot;), limits = c(min,max)) + ggplot2::theme_minimal() + ggplot2::theme( axis.text.x = element_text( angle = 60, hjust = 1, size = 9)) + ggplot2::labs( title = &quot;Month in which BILLED activity occurred&quot;, x = &quot;Date&quot;, y = &quot;Number of activities&quot;) It will be most useful to explore the characteristics known when the first activity (NEW) is carried out. In this way the early information at case start could be used to predict and better understand in which of the two time periods the BILLED activity is likely to occur. Below we extract the characteristics at the start of the process for each case. We also categorise the very detailed diagnosis column by extracting just the first letter of the full diagnosis code. This is so that the plots created are less complicated. predictors_at_NEW &lt;- eventdataR::hospital_billing %&gt;% edeaR::filter_activity(activities = c(&quot;NEW&quot;)) %&gt;% tibble::as_tibble() %&gt;% dplyr::select(case_id,actorange:speciality) %&gt;% dplyr::mutate(diagnosis_cat = stringr::str_sub(string = diagnosis, start = 1, end = 1)) First we see what is contained in each predictor quickly using skimr. library(skimr) skimr::skim(predictors_at_NEW) ## Skim summary statistics ## n obs: 11106 ## n variables: 18 ## ## -- Variable type:character ------------------- ## variable missing complete n min max empty n_unique ## actorange 11106 0 11106 NA NA 0 0 ## actred 11106 0 11106 NA NA 0 0 ## blocked 1106 10000 11106 5 5 0 1 ## case_id 1 11105 11106 1 3 0 9999 ## casetype 1106 10000 11106 1 1 0 7 ## closecode 11106 0 11106 NA NA 0 0 ## diagnosis 6456 4650 11106 1 3 0 467 ## diagnosis_cat 6456 4650 11106 1 1 0 26 ## flaga 1106 10000 11106 5 5 0 1 ## flagb 1106 10000 11106 5 5 0 1 ## flagc 11106 0 11106 NA NA 0 0 ## flagd 1105 10001 11106 4 5 0 2 ## iscancelled 1106 10000 11106 5 5 0 1 ## isclosed 1098 10008 11106 4 5 0 2 ## msgcode 11106 0 11106 NA NA 0 0 ## msgtype 11106 0 11106 NA NA 0 0 ## speciality 1106 10000 11106 1 1 0 22 ## ## -- Variable type:integer --------------------- ## variable missing complete n mean sd p0 p25 p50 p75 p100 hist ## msgcount 11106 0 11106 NaN NA NA NA NA NA NA predictors_at_NEW &lt;- predictors_at_NEW %&gt;% dplyr::select(-actorange,-actred,-closecode,-flagc,-msgcode,-msgtype) The skimr output shows 6 columns with all missing values we can remove as they offer no information. Next, we join the first known case characteristics (from when the case started at the NEW activity) to the final BILLED activity rows. billed &lt;- eventdataR::hospital_billing %&gt;% edeaR::filter_activity(activities = c(&quot;BILLED&quot;)) %&gt;% dplyr::mutate(day = lubridate::as_date(timestamp), month = base::cut(day, &quot;month&quot;), month = lubridate::as_date(month)) %&gt;% tibble::as_tibble() %&gt;% dplyr::select(case_id,day,month) %&gt;% dplyr::left_join(predictors_at_NEW) ## Joining, by = &quot;case_id&quot; Finally, we can plot different case characteristics by the month in which the final case activity BILLED occurred. Starting with casetype we can see a strong relationship with values A and B. These two values each dominate each of the two peaks separately. The second peak in January to April 2014 was almost all casetype value “A” or “NA” at the first activity (NEW). While the first peak is almost all casetype value “B” at the first activity. billed %&gt;% dplyr::group_by(month,casetype) %&gt;% dplyr::summarise(n = n()) %&gt;% dplyr::ungroup() %&gt;% ggplot2::ggplot() + ggplot2::aes(x = month, y = n, colour = casetype, fill = casetype) + ggplot2::geom_bar(stat = &quot;identity&quot;) + ggplot2::scale_x_date(date_breaks = &quot;1 month&quot;, labels = scales::date_format(&quot;%b %y&quot;)) + ggplot2::theme_minimal() + ggplot2::theme( axis.text.x = element_text( angle = 60, hjust = 1, size = 9)) + ggplot2::labs( #title = paste(casetype,&quot; by BILLED month&quot;), x = &quot;Date&quot;, y = &quot;Number of activities&quot;) casetype does not entirely explain the two peaks (i.e. sometimes other casetype values occur). Below we put the ggplot code from above into a function so that it is easy to repeat the plot for more of the case characteristics known at the start of the case. plot_fun &lt;- function(cat){ cat &lt;- ensym(cat) billed %&gt;% dplyr::group_by(month,!!cat) %&gt;% dplyr::summarise(n = n()) %&gt;% ggplot2::ggplot() + ggplot2::aes(x = month, y = n, colour = !!cat, fill = !!cat) + ggplot2::geom_bar(stat = &quot;identity&quot;) + ggplot2::scale_x_date(date_breaks = &quot;1 month&quot;, labels = scales::date_format(&quot;%b %y&quot;)) + ggplot2::theme_minimal() + ggplot2::theme( axis.text.x = element_text( angle = 60, hjust = 1, size = 9)) + ggplot2::labs( title = paste(&quot;Value of &quot;,cat,&quot;during activity NEW shown by BILLED month&quot;), x = &quot;Date&quot;, y = &quot;Number of activities&quot;) } In the plots below the diagnosis column is mostly “NA” at the earlier peak of BILLED activities, while all the other diganosis categories are more common than “NA” in the second peak of BILLED activity. Show all the plots vars &lt;- c(&quot;blocked&quot;,&quot;diagnosis_cat&quot;,&quot;flaga&quot;,&quot;flagb&quot;,&quot;flagd&quot;,&quot;iscancelled&quot;,&quot;isclosed&quot;,&quot;msgcount&quot;,&quot;speciality&quot;) purrr::map(vars,plot_fun) ## [[1]] ## ## [[2]] ## ## [[3]] ## ## [[4]] ## ## [[5]] ## ## [[6]] ## ## [[7]] ## ## [[8]] ## ## [[9]] If we wanted to predict the eventual age of the case when it reaches the BILLED activity from what we knew about the case at the first NEW activity, knowing if it is casetype “A”, “B” or “NA” will be a good predictor. Also, cases which move quickly from the first NEW activity to CHANGE DIAGN (with an average of 0 days) their subsequent average time to the FIN activity is only 89 days, but much longer for cases that move directly from NEW to FIN (with an average time of 361 days). This means that the activities that cases pass through should also help us predict the case age when it is in-flight, and not just from what we knew about the case when it began. There are likely to be complex combinations of additional predictors or “features” that could be used to predict the most likely case age. In a later chapter we introduce the caret package as a way to automatically combine values to create more accurate predictions. 8.5 Process Discovery algorithms There are also algorithmic methods designed to reveal important paths and the causal structure among the complexity of the raw spaghetti-like process maps. They include the Heuristics Miner package and the Fuzzy Miner package that represent the process as a simplified model. 8.5.1 Flexible Heuristics Miner The Flexible Heuristics Miner algorithm is well explained in the Flexible Heuristics Miner paper using worked examples and set notation. First we create a simple precedence matrix. The activities on the left hand y axis are the antecedent (so come first in the process), while the activities along the bottom x axis are the consequent (so occur after the antecedent). A more literal description of a precedence matrix is a “directly-follows frequency matrix”. p_matrix &lt;- heuristicsmineR::precedence_matrix_absolute(eventlog = eventdataR::hospital_billing) new_levs &lt;- base::sort(base::levels(p_matrix$antecedent)) levels(p_matrix$antecedent) &lt;- new_levs levels(p_matrix$consequent) &lt;- new_levs p1 &lt;- p_matrix %&gt;% ggplot2::ggplot() + ggplot2::aes(x = consequent, y = antecedent, fill = n) + ggplot2::geom_raster()+ ggplot2::geom_text(aes(label = base::ifelse(n&gt;0, base::format(n, big.mark = &quot;,&quot;, scientific = FALSE), NA)), size = 3, angle = 60) + ggplot2::scale_fill_gradient(low = &quot;white&quot;, high = &quot;red&quot;) + ggplot2::theme_minimal() + ggplot2::theme(axis.text.x = element_text(angle = 60, hjust = 1), legend.position = &quot;none&quot;, axis.title.y = element_text(angle = 0, vjust = 0.5)) + ggplot2::labs(x = &quot;Consequent&quot;, y = &quot;Antecedent&quot;) p1 A lower code version of the … is.. eventdataR::hospital_billing %&gt;% processmapR::precedence_matrix(type = &quot;absolute&quot;) %&gt;% plot() This precedence matrix is equivalent to the FHM algorithm example in Table 2 of the Flexible Heuristics Miner paper. Using heuristicsmineR::precedence_matrix_length_two_loops() we can also create “length two loops”. This shows which activities recurring after a different activity is carried out. For example, the value 129 and STORNO,BILLED tells us there were 129 STORNO,BILLED,STORNO activity sequences in the event log. This matrix is equivalent to the worked FHM algorithm example in Table 3 of the Flexible Heuristics Miner paper. p_matrix &lt;- heuristicsmineR::precedence_matrix_length_two_loops(eventlog = eventdataR::hospital_billing) p2 &lt;- p_matrix %&gt;% ggplot2::ggplot() + ggplot2::aes(x = consequent, y = antecedent, fill = n) + ggplot2::geom_tile()+ ggplot2::geom_text(aes(label = base::ifelse(n&gt;0, base::format(n, big.mark = &quot;,&quot;, scientific = FALSE), NA)), size = 3) + ggplot2::scale_fill_gradient(low = &quot;white&quot;, high = &quot;red&quot;) + ggplot2::theme_minimal() + ggplot2::theme(axis.text.x = element_text(angle = 60, hjust = 1), legend.position = &quot;none&quot;, axis.title.y = element_text(angle = 0, vjust = 0.5)) + ggplot2::labs(x = &quot;Consequent&quot;, y = &quot;Antecedent&quot;) p2 The heuristicsmineR::dependency_matrix() calculates formula (1) in the Flexible Heuristics Miner paper. In words, the formula is the number of times activity B follows activity A, minus the other direction (A follows B), divided by the sum of the previous two values plus one. The value is always between -1 and 1. A high value indicates a dependency relation in that direction. Below we calculate the dependency matrix and illustrate the calculation with one task pair following the text at the start of section 4.1 of the FHM paper. dm &lt;- heuristicsmineR::dependency_matrix(eventlog = eventdataR::hospital_billing, threshold = 0) t &lt;- base::as.data.frame(dm) %&gt;% dplyr::filter(consequent != &quot;End&quot;) new_levs &lt;- base::sort(base::levels(t$antecedent)) levels(t$antecedent) &lt;- new_levs levels(t$consequent) &lt;- new_levs p3 &lt;- t %&gt;% ggplot2::ggplot() + ggplot2::aes(x = consequent, y = antecedent, fill = dep) + ggplot2::geom_tile()+ ggplot2::geom_text(aes(label = round(dep,1)), size = 3) + ggplot2::scale_fill_gradient(low = &quot;white&quot;, high = &quot;orange&quot;) + ggplot2::theme_minimal() + ggplot2::theme(axis.text.x = element_text(angle = 60, hjust = 1), legend.position = &quot;none&quot;, axis.title.y = element_blank(), axis.text.y = element_blank()) p3 &lt;- p3 + ggplot2::theme(axis.title.y = element_blank()) p1 &lt;- p1 + ggplot2::theme(axis.title.y = element_text(angle = 90)) cowplot::plot_grid(p1, p3, labels = c(&#39;Directly-follows frequency matrix&#39;, &#39;Dependency matrix&#39;), label_size = 12, vjust = 1) In the left hand matrix above the task CODE ERROR is directly followed two times by task REOPEN, but the other way never occurs. This means that the dependency relation value of CODE ERROR ⇒W REOPEN = (2 - 0) / (2 + 0 + 1) = 0.7. This indicates we are not completely sure of the dependency relation with only two observations. However, if CODE ERROR is directly followed by REOPEN many more times than two (say 50 times) and the other way around never occurs we can be much more certain there is a dependency relation. The value would then be CODE ERROR ⇒W REOPEN = (50 - 0) / (50 + 0 + 1) = 0.98 which is much closer to one indicating a very strong dependence relation. If noise caused CODE ERROR to follow REOPEN once, the value of CODE ERROR ⇒W REOPEN is (50 -1) / (50 + 1 + 1) = 0.94. This is only a little lower and indicates we are still confident of a dependency relation with the value being so close to 1. If we alter the threshold value for which we will accept a dependency relation (e.g. values above 0.9) then view that in a matrix, we can be fairly certain there is a causality between the antecedent and consequent activities shown below. dm &lt;- heuristicsmineR::dependency_matrix(eventlog = eventdataR::hospital_billing, threshold = 0.9, all_connected = TRUE) base::as.data.frame(dm) %&gt;% ggplot2::ggplot() + ggplot2::aes(x = consequent, y = antecedent, fill = dep) + ggplot2::geom_raster()+ ggplot2::geom_text(aes(label = round(dep, 1))) + ggplot2::scale_fill_gradient(low = &quot;white&quot;, high = &quot;orange&quot;) + ggplot2::theme_minimal() + ggplot2::theme(axis.text.x = element_text(angle = 60, hjust = 1), axis.title.y = element_text(angle = 0, vjust = 0.5), legend.position = &quot;none&quot;)+ ggplot2::labs(x = &quot;Consequent&quot;, y = &quot;Antecedent&quot;) We can also render the simplified matrix of strong dependency relations above 0.9 into a diagram. This shows the dependency relation value on each arrow that is always above 0.9. dm %&gt;% heuristicsmineR::render_dependency_matrix() A causal net uses the dependency graph above but annotated to show the number of cases that pass through each activity when the dependency relation is set at 0.9. cn &lt;- heuristicsmineR::causal_net(eventdataR::hospital_billing, dependencies = dm) cn %&gt;% heuristicsmineR::render_causal_net() So if we created a dependency matrix with a much lower threshold the causal net would have more paths and be more complex. dm &lt;- heuristicsmineR::dependency_matrix(eventlog = eventdataR::hospital_billing, threshold = 0.1, all_connected = TRUE) heuristicsmineR::causal_net(eventdataR::hospital_billing, dependencies = dm) %&gt;% heuristicsmineR::render_causal_net() Dependency graphs and causal nets are described in this [Coursera Process Mining] lecture(https://www.coursera.org/lecture/process-mining/3-4-dependency-graphs-and-causal-nets-ozi0S) 8.5.2 Fuzzy miner In the paper Data-driven process discovery : revealing conditional infrequent behavior from event logs section 5.2, figure 6, fuzzymineR is demonstrated on the hospital billing data. Unfortunately, attempting to replicate that figure returns an error. metrics &lt;- fuzzymineR::mine_fuzzy_model(eventdataR::hospital_billing) ## | | | 0% ## Error in apply(trace_events, 1, addEvent): dim(X) must have a positive length #So that [fuzzymineR](https://github.com/nirmalpatel/fuzzymineR/blob/master/README.md) would operate [this](https://stackoverflow.com/a/27667945) setting was altered to the following value: `Sys.setenv(JAVA_HOME=&#39;C:\\\\Program Files (x86)\\\\Java\\\\jre1.8.0_231&#39;)`. Due to the error we run the algorithm with the eventdataR::traffic_fines event log that is also demonstrated in section 5.2. # Mine the fuzzy model metrics &lt;- fuzzymineR::mine_fuzzy_model(eventdataR::traffic_fines) Then we can visualize the fuzzy model for a given set of parameters. p &lt;- fuzzymineR::viz_fuzzy_model(metrics = metrics, node_sig_threshold = 0, edge_sig_threshold = 0.4, edge_sig_to_corr_ratio = 0.75, preserve_threshold = 0.4) t &lt;- p$x$diagram t &lt;- stringr::str_replace(t,&#39;layout = \\&quot;dot&#39;,&#39;layout = \\&quot;neato&#39;) p$x$diagram &lt;- t p Which can be compared to the full complex process map for traffic fines to determine if the fuzzymineR map is useful for process discovery. eventdataR::traffic_fines %&gt;% processmapR::process_map(type = frequency(&quot;absolute&quot;)) "],
["tables.html", "Chapter 9 Tables 9.1 DataTable basic 9.2 DataTable (bells &amp; whistles) 9.3 Colour DataTable with formattable 9.4 rpivottable basic 9.5 rpivottable (bells &amp; whistles)", " Chapter 9 Tables 9.1 DataTable basic We usually plot tidy data where the data frame is “long”. But for easy to read tables we will often want to reshape our long data to “wide”. In the Texas housing sales data, this means showing one column per month (rather than one row per month in tidy data). To make the data wide we use tidyr::pivot_wider() then pipe that wide data into DT::datatable() to create an interactive table very easily. # first reshape with new tidyr df_wide &lt;- df %&gt;% dplyr::filter(year == 2014) %&gt;% dplyr::arrange(city,date) %&gt;% dplyr::mutate(date1 = base::format(date, &quot;%b %y&quot;)) %&gt;% tidyr::pivot_wider(id_cols = city, names_from = date1, values_from = sales) df_wide %&gt;% DT::datatable(df_wide) 9.2 DataTable (bells &amp; whistles) The DT DataTables reference describes all the DataTable elements you can change with clear examples and code. This resource is usually all you need to refer to. Eventually you will have chosen lots of different DataTable options to apply. However, if your work includes many tables, this will lead to lots of repeated settings code. Reduce the amount of code by setting the default table options globally like this. options(DT.options = list( pageLength = 10, lengthMenu = c(5, 10, 20, 50, 100, 200, 500), dom = &quot;Blfrtip&quot;, buttons = list(list(extend = &quot;csv&quot;, filename = &quot;download&quot;)), keys = TRUE, autoWidth = TRUE )) The default settings above will then be applied every time you use DT::datatable() df_wide %&gt;% DT::datatable( caption = &quot;Housing sales&quot;, filter = &quot;top&quot;, extensions = c(&quot;FixedColumns&quot;, &quot;Buttons&quot;), options = list(columnDefs = list(list(width = &quot;150px&quot;, targets = c(1)))) ) 9.3 Colour DataTable with formattable Colouring DataTable cells based on the value it contains is a common client request. Here is a code template you can re-use that is like Excel’s conditional formatting. # find 8 cut points going from the smallest to the largest value of sales in 2014 cuts &lt;- base::seq(from = min(df$sales[df$year==2014], na.rm = TRUE), to = max(df$sales[df$year==2014], na.rm=TRUE), length.out = 8) # define 9 colours for those cut points (1 more than the cut points needed) colours &lt;- RColorBrewer::brewer.pal(n = 9,name = &quot;Blues&quot;) # columns to format cols &lt;- base::seq(from = 2, to = ncol(df_wide), by = 1) df_wide %&gt;% dplyr::mutate_if(.predicate = base::is.character, .funs = base::as.factor) %&gt;% # converts an character columns to a factor so that the drop down menu works in the DataTable DT::datatable( caption = &quot;Housing sales&quot;, filter = &quot;top&quot;, extensions = c(&quot;FixedColumns&quot;, &quot;Buttons&quot;), options = list(columnDefs = list(list(width = &quot;150px&quot;, targets = c(1)))) ) %&gt;% DT::formatStyle(columns = cols, background = DT::styleInterval(cuts = cuts, values = colours)) %&gt;% DT::formatCurrency(columns = cols, currency = &quot;&quot;, digits = 0, interval = 3, mark = &#39;,&#39;) 9.4 rpivottable basic I love Excel pivot tables and charts for exploring data. rpivotTables are a similar exploratory tool in R. We simply put the dataframe into the function rpivotTable::rpviotTable() then play around with the html output below (as you would with an Excel pivot table). df_red %&gt;% rpivotTable::rpivotTable() 9.5 rpivottable (bells &amp; whistles) Once we’ve decided how we want the rpivotTable to look manually we can hard code the layout to tell a particular story for our audience. df_red %&gt;% rpivotTable::rpivotTable( rows = c(&quot;year&quot;,&quot;city&quot;), cols = &quot;date&quot;, inclusions = list(year = list(&quot;2014&quot;)), aggregatorName = &quot;Sum&quot;, vals = &quot;sales&quot;, rendererName = &quot;Line Chart&quot;) "],
["colours.html", "Chapter 10 Colours 10.1 RColorBrewer 10.2 Prismatic 10.3 Hand-picked colours", " Chapter 10 Colours 10.1 RColorBrewer We have already been setting colours in some of the previous plots using the RColorBrewer package. RColourBrewer contains ready-made colour palettes. We can view all the palettes it contains in one picture like this. # easy colours RColorBrewer::display.brewer.all() We can also filter the picture above to show only palettes friendly to people who are colour blind. display.brewer.all(colorblindFriendly = TRUE) And we can create a palette of colours with a specific number of colours like this. Then view them in a simple bar plot. mypalette &lt;- RColorBrewer::brewer.pal(9,&quot;Set2&quot;) ## Warning in RColorBrewer::brewer.pal(9, &quot;Set2&quot;): n too large, allowed maximum for palette Set2 is 8 ## Returning the palette you asked for with that many colors graphics::barplot(1:9,col = mypalette) 10.2 Prismatic Prismatic lets us play around with colour palettes by shifting one aspect of all of the colours it contains at the same time. For example, below, we start with the terrain palette in the prismatic package. terrain &lt;- prismatic::colour(terrain.colors(10)) plot(terrain) Now we turn the palette grey. terrain_gray &lt;- prismatic::clr_grayscale(terrain) plot(terrain_gray) Darken the palette. terrain_darken &lt;- prismatic::clr_darken(terrain) plot(terrain_darken) Make the palette negative. terrain_negate &lt;- prismatic::clr_negate(terrain) plot(terrain_negate) 10.3 Hand-picked colours You can also hand-pick your colour palette from this colour picking website. The website is recommended by Michael Toth in his excellent detailed guide to ggplot colours. The colour picking website was used to create and then copy and paste the colours into this palette below. newpalette &lt;- c(&quot;#804759&quot;,&quot;#713E4E&quot;,&quot;#633543&quot;,&quot;#562D39&quot;,&quot;#48252F&quot;,&quot;#3B1D25&quot;) barplot(1:6,col = newpalette) "],
["final-document.html", "Chapter 11 Final document 11.1 Picking a final output doc 11.2 flexdashboard (vs Shiny) 11.3 R markdown with floating contents and tabbed sections 11.4 bookdown", " Chapter 11 Final document 11.1 Picking a final output doc It is hard but satisfying work to explore your data and tell interesting stories in polished plots. An important final step is to show it off in easy to navigate HTML documents. Here are three good options. 11.2 flexdashboard (vs Shiny) This Flexdashboard by Matt Dray is a fantastic working example. It includes some of the interactivity we saw earlier using crosstalk, plotly and DT tables described in the Interactive plots chapter. Also, here is an easy to follow tutorial about how to build flexdashboards Flexdashboards using crosstalk are an excellent alternative to a shinydashboard as the code is much easier to build and edit. It is because the interactivity for the user is taken care of by the simple crosstalk options. In contrast, with Shiny you will need to understand, build, and maintain the more complex reactivity of your app. As well as needing a platform to deploy your shiny app. In contrast, with flexdashboard, you can email the HTML document it creates to your audience. However, if your flexdashboard presents a lot of data in its plots and tables this can make the HTML doc that flexdashboard creates large and too slow to open for users. Shiny does not suffer from this as it only pulls the data the user requests from the selections they have make (e.g. with drop-down menus). In other words, when you open a Shiny app the front end doesn’t contain all of the data a user could view, but in flexdashboard it does. Shiny is also a better option when you want to give users a greater range of interactive plots and selection options than crosstalk can provide. Crosstalk is limited to basic filtering for only a limited number of html widgets. In contrast, Shiny can be set up to allow users to interact with pretty much any R package you want to use in your app. 11.3 R markdown with floating contents and tabbed sections When using R markdown I’ve found a floating table of contents and tabbed sections are the most effective for providing compact and easy to navigate HTML documents, particularly when you are presenting a lot of information at once, such as a detailed report. 11.4 bookdown Finally, how this book itself is created is surprisingly quick to do. Here is a board bookdown guide to follow. Here is how I built this book: Clone or download this minimal example. Add this line…. output_dir: \"docs\" …to the configuration file _bookdown.yml (as described here) In RStudio build the book to gitbook format either using the drop down in the build tab (next to Environment tab), or by running this line of code.. rmarkdown::render_site(output_format = 'bookdown::gitbook', encoding = 'UTF-8') …this builds the book into a single docs folder holding all the html files needed in it. Push the docs folder to your GitHub repository so it’s ready to publish. Now on GitHub website follow this guidance. It describes how you go to the Settings of the repository, then GitHub Pages section, then the Source section that has a drop-down. Select the third option of the Source drop-down that is…. master branch/docs folder Use only the docs folder for Github pages ..it then has a bit of a think then tells you when the published book is ready to view and at what web address. "]
]
